diff --git a/arch/arm64/boot/dts/rockchip/rk3308.dtsi b/arch/arm64/boot/dts/rockchip/rk3308.dtsi
index 4b6058e30858..8693e4dac4f2 100644
--- a/arch/arm64/boot/dts/rockchip/rk3308.dtsi
+++ b/arch/arm64/boot/dts/rockchip/rk3308.dtsi
@@ -221,7 +221,7 @@
 			route_rgb: route-rgb {
 				status = "disabled";
 				logo,uboot = "logo.bmp";
-				/* logo,kernel = "logo_kernel.bmp"; */
+				logo,kernel = "logo_kernel.bmp";
 				logo,mode = "center";
 				charge_logo,mode = "center";
 				connect = <&vop_out_rgb>;
diff --git a/arch/arm64/boot/dts/rockchip/rk3308b-evb-v10.dtsi b/arch/arm64/boot/dts/rockchip/rk3308b-evb-v10.dtsi
index fc7a899e710e..17a538f94a1f 100644
--- a/arch/arm64/boot/dts/rockchip/rk3308b-evb-v10.dtsi
+++ b/arch/arm64/boot/dts/rockchip/rk3308b-evb-v10.dtsi
@@ -12,7 +12,7 @@
 	compatible = "rockchip,rk3308b-evb-v10", "rockchip,rk3308";
 
 	chosen {
-		bootargs = "earlycon=uart8250,mmio32,0xff0e0000 swiotlb=1 console=ttyFIQ0 root=PARTUUID=614e0000-0000 rootfstype=squashfs rootwait snd_aloop.index=7 snd_aloop.use_raw_jiffies=1";
+		bootargs = "earlycon=uart8250,mmio32,0xff0c0000 swiotlb=1 console=ttyFIQ0 root=PARTUUID=614e0000-0000 rootfstype=squashfs rootwait snd_aloop.index=7 snd_aloop.use_raw_jiffies=1";
 	};
 
 	acodec_sound: acodec-sound {
@@ -106,7 +106,7 @@
 		 * - SDIO_RESET_L_WL_REG_ON
 		 * - PDN (power down when low)
 		 */
-		reset-gpios = <&gpio4 RK_PD6 GPIO_ACTIVE_LOW>;
+		reset-gpios = <&gpio4 RK_PB3 GPIO_ACTIVE_LOW>;
 	};
 
 	spdif_rx_sound: spdif-rx-sound {
@@ -297,7 +297,7 @@
 };
 
 &fiq_debugger {
-	rockchip,serial-id = <4>;
+	// rockchip,serial-id = <4>;
 	status = "okay";
 };
 
@@ -699,13 +699,13 @@
 
 	sdio-pwrseq {
 		wifi_enable_h: wifi-enable-h {
-			rockchip,pins = <4 RK_PD6 RK_FUNC_GPIO &pcfg_pull_none>;
+			rockchip,pins = <4 RK_PB3 RK_FUNC_GPIO &pcfg_pull_none>;
 		};
 	};
 
 	wireless-wlan {
 		wifi_wake_host: wifi-wake-host {
-			rockchip,pins = <2 RK_PB4 RK_FUNC_GPIO &pcfg_pull_up>;
+			rockchip,pins = <4 RK_PB5 RK_FUNC_GPIO &pcfg_pull_up>;
 		};
 	};
 };
diff --git a/arch/arm64/boot/dts/rockchip/rk3308bs-evb-amic-v11.dts b/arch/arm64/boot/dts/rockchip/rk3308bs-evb-amic-v11.dts
index 099c6de3e58f..d884a1232cbd 100644
--- a/arch/arm64/boot/dts/rockchip/rk3308bs-evb-amic-v11.dts
+++ b/arch/arm64/boot/dts/rockchip/rk3308bs-evb-amic-v11.dts
@@ -6,7 +6,7 @@
 /dts-v1/;
 
 #include "rk3308bs-evb-v11.dtsi"
-
+#include "rk3308bs-evb-ext-v10.dtsi"
 / {
 	model = "Rockchip RK3308B-S evb analog mic v11 board";
 	compatible = "rockchip,rk3308bs-evb-amic-v11", "rockchip,rk3308";
@@ -29,20 +29,20 @@
 	rockchip,adc-grps-route = <1 2 3 0>;
 };
 
-&bluetooth_sound {
-	status = "okay";
-};
-
-&i2s_8ch_0 {
-	status = "okay";
-	#sound-dai-cells = <0>;
-	rockchip,clk-trcm = <1>;
-	pinctrl-names = "default";
-	pinctrl-0 = <&i2s_8ch_0_sclktx
-		     &i2s_8ch_0_lrcktx
-		     &i2s_8ch_0_sdi0
-		     &i2s_8ch_0_sdo2>;
-};
+// &bluetooth_sound {
+// 	status = "okay";
+// };
+
+// &i2s_8ch_0 {
+// 	status = "okay";
+// 	#sound-dai-cells = <0>;
+// 	rockchip,clk-trcm = <1>;
+// 	pinctrl-names = "default";
+// 	pinctrl-0 = <&i2s_8ch_0_sclktx
+// 		     &i2s_8ch_0_lrcktx
+// 		     &i2s_8ch_0_sdi0
+// 		     &i2s_8ch_0_sdo2>;
+// };
 
 &is31fl3236 {
 	reg = <0x3f>;
diff --git a/arch/arm64/boot/dts/rockchip/rk3308bs-evb-ext-v10.dtsi b/arch/arm64/boot/dts/rockchip/rk3308bs-evb-ext-v10.dtsi
new file mode 100644
index 000000000000..84772c294373
--- /dev/null
+++ b/arch/arm64/boot/dts/rockchip/rk3308bs-evb-ext-v10.dtsi
@@ -0,0 +1,235 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2018 Fuzhou Rockchip Electronics Co., Ltd
+ *
+ */
+
+/ {
+	backlight: backlight {
+		status = "okay";
+		compatible = "pwm-backlight";
+		pwms = <&pwm10 0 50000 0>;
+		brightness-levels = <
+			  0   1   2   3   4   5   6   7
+			  8   9  10  11  12  13  14  15
+			 16  17  18  19  20  21  22  23
+			 24  25  26  27  28  29  30  31
+			 32  33  34  35  36  37  38  39
+			 40  41  42  43  44  45  46  47
+			 48  49  50  51  52  53  54  55
+			 56  57  58  59  60  61  62  63
+			 64  65  66  67  68  69  70  71
+			 72  73  74  75  76  77  78  79
+			 80  81  82  83  84  85  86  87
+			 88  89  90  91  92  93  94  95
+			 96  97  98  99 100 101 102 103
+			104 105 106 107 108 109 110 111
+			112 113 114 115 116 117 118 119
+			120 121 122 123 124 125 126 127
+			128 129 130 131 132 133 134 135
+			136 137 138 139 140 141 142 143
+			144 145 146 147 148 149 150 151
+			152 153 154 155 156 157 158 159
+			160 161 162 163 164 165 166 167
+			168 169 170 171 172 173 174 175
+			176 177 178 179 180 181 182 183
+			184 185 186 187 188 189 190 191
+			192 193 194 195 196 197 198 199
+			200 201 202 203 204 205 206 207
+			208 209 210 211 212 213 214 215
+			216 217 218 219 220 221 222 223
+			224 225 226 227 228 229 230 231
+			232 233 234 235 236 237 238 239
+			240 241 242 243 244 245 246 247
+			248 249 250 251 252 253 254 255>;
+		default-brightness-level = <200>;
+	};
+
+	panel: panel {
+		compatible = "simple-panel";
+		bus-format = <MEDIA_BUS_FMT_RGB888_1X24>;
+		backlight = <&backlight>;
+		enable-gpios = <&gpio0 RK_PB6 GPIO_ACTIVE_LOW>;
+		enable-delay-ms = <200>;
+		reset-gpios = <&gpio0 RK_PA3 GPIO_ACTIVE_LOW>;
+		reset-delay-ms = <200>;
+		init-delay-ms = <200>;
+		// prepare-delay-ms = <20>;
+		// unprepare-delay-ms = <20>;
+		// disable-delay-ms = <20>;
+		width-mm = <160>;
+		height-mm = <60>;
+		status = "okay";
+		spi-sdc-gpios = <&gpio2 RK_PB2 GPIO_ACTIVE_HIGH>;
+		spi-shut-gpios = <&gpio2 RK_PB1 GPIO_ACTIVE_HIGH>;
+		spi-sdo-gpios = <&gpio1 RK_PC6 GPIO_ACTIVE_HIGH>;
+		spi-sdi-gpios = <&gpio1 RK_PC7 GPIO_ACTIVE_HIGH>;
+		spi-scl-gpios = <&gpio1 RK_PD0 GPIO_ACTIVE_HIGH>;
+		spi-cs-gpios = <&gpio1 RK_PD1 GPIO_ACTIVE_HIGH>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&spi_init_cmd>;
+		rockchip,cmd-type = "myspi";
+		rgb-mode = "p888";
+		power_enable = <1>;
+
+		panel-init-sequence = [
+			/* type delay num val1 val2 val3 */
+			00 00 03 f0 5a 59
+			00 00 03 f1 a5 a6
+			00 00 0f b0 54 32 23 45 44 44 44 44 9f 00 01 9f 00 01
+			00 00 0b b1 32 84 02 83 29 06 06 72 06 06
+			00 00 02 b2 73
+			00 00 15 b3 0b 09 13 11 0f 0d 00 00 00 03 00 03 03 03 03 03 03 03 05 07
+			00 00 15 b4 0a 08 12 10 0e 0c 00 00 00 03 00 03 03 03 03 03 03 03 04 06
+			00 00 03 b6 13 13
+			00 00 05 b8 b4 43 02 cc
+			00 00 05 b9 a5 20 ff c8
+			00 00 03 ba 88 23
+			00 00 0b bd 43 0e 0e 50 50 29 10 03 44 03
+			00 00 09 c1 00 0c 16 04 00 30 10 04
+			00 00 03 c2 21 81
+			00 00 03 c3 02 30
+			00 00 03 c7 25 6a
+			00 00 27 c8 7c 68 59 4e 4b 3c 41 2b 44 43 43 60 4e 55 47 44 38 27 06 7c 68 59 4e 4b 3c 41 2b 44 43 43 60 4e 55 47 44 38 27 06
+			00 00 07 d4 00 00 00 32 04 51
+			00 00 03 f1 5a 59
+			00 00 03 f0 a5 a6
+			01 00 02 36 14
+			01 00 02 35 00
+			01 78 01 11
+			01 14 01 29
+			
+		];
+		panel-exit-sequence = [
+			/* type delay num val1 val2 val3 */
+			00   0a  01  28
+			00   78  01  10
+		];
+
+		display-timings {
+			native-mode = <&stt0430_enl2c_timing>;
+
+			stt0430_enl2c_timing: timing0 {
+				clock-frequency = <42000000>;
+				hactive = <400>;
+				vactive = <1280>;
+				hback-porch = <80>;
+				hfront-porch = <80>;
+				vback-porch = <12>;
+				vfront-porch = <10>;
+				hsync-len = <4>;
+				vsync-len = <4>;
+				hsync-active = <0>;
+				vsync-active = <0>;
+				de-active = <0>;
+				pixelclk-active = <0>;
+			};
+		};
+
+		port {
+			panel_in_rgb: endpoint {
+				remote-endpoint = <&rgb_out_panel>;
+			};
+		};
+	};
+};
+
+&pinctrl {
+	spi_panel {
+		spi_init_cmd: spi-init-cmd {
+			rockchip,pins =
+				/* spi enable */
+                <0 RK_PB6 RK_FUNC_GPIO &pcfg_pull_none>,
+				/* spi reset */
+                <0 RK_PA3 RK_FUNC_GPIO &pcfg_pull_none>,
+				/* spi sdc */
+                <2 RK_PB2 RK_FUNC_GPIO &pcfg_pull_none>,
+				/* spi shut */
+                <2 RK_PB1 RK_FUNC_GPIO &pcfg_pull_none>,
+				/* spi sdo */
+                <1 RK_PC6 RK_FUNC_GPIO &pcfg_pull_none>,
+				/* spi sdi */
+				<1 RK_PC7 RK_FUNC_GPIO &pcfg_pull_none>,
+				/* spi scl */
+				<1 RK_PD0 RK_FUNC_GPIO &pcfg_pull_none>,
+				/* spi cs */
+				<1 RK_PD1 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+	};
+	i2c_tp {
+		i2c_tp_init: i2c_tp_init{
+			rockchip,pins = 
+				/*int pin*/
+				<0 RK_PC0 RK_FUNC_GPIO &pcfg_pull_none>,
+				/*rest pin*/
+				<0 RK_PC1 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+	};
+};
+
+&display_subsystem {
+	status = "okay";
+};
+
+&pwm10 {
+	status = "okay";
+};
+
+&rgb {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&lcdc_ctl &lcdc_rgb888_m1>;
+
+	ports {
+		rgb_out: port@1 {
+			reg = <1>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			rgb_out_panel: endpoint@0 {
+				reg = <0>;
+				remote-endpoint = <&panel_in_rgb>;
+			};
+		};
+	};
+};
+
+&route_rgb {
+	status = "okay";
+};
+
+&vop {
+	status = "okay";
+};
+
+&i2c1 {
+    status = "okay";
+    clock-frequency = <100000>;
+   
+	hy4635@48 {
+        compatible = "rockchip,hy4635";
+        reg = <0x48>;
+		interrupt-parent = <&gpio0>;
+		interrupts = <RK_PC0 IRQ_TYPE_EDGE_BOTH>;
+		reset-gpios = <&gpio0 RK_PC1 GPIO_ACTIVE_LOW>;
+		intt-gpios = <&gpio0 RK_PC0 GPIO_ACTIVE_LOW>;
+        pinctrl-names = "default";
+        pinctrl-0 = <&i2c_tp_init>;
+        touchscreen-size-x = <1280>;
+		touchscreen-size-y = <400>;
+		touchscreen-fuzz-x = <0>;
+		touchscreen-fuzz-y = <0>;
+		//touchscreen-inverted-x;
+		//touchscreen-inverted-y;
+		//touchscreen-swapped-x-y;
+		status = "okay";
+    };
+};
+
+&uart0 {
+	status = "okay";
+};
+
+&uart4 {
+	status = "okay";
+};
diff --git a/arch/arm64/boot/dts/rockchip/rk3308bs-evb-v11.dtsi b/arch/arm64/boot/dts/rockchip/rk3308bs-evb-v11.dtsi
index 2de3c86da28a..cdd49f4192f6 100644
--- a/arch/arm64/boot/dts/rockchip/rk3308bs-evb-v11.dtsi
+++ b/arch/arm64/boot/dts/rockchip/rk3308bs-evb-v11.dtsi
@@ -31,7 +31,7 @@
 		pinctrl-1 = <&uart0_rts_gpio>;
 		BT,power_gpio    = <&gpio2 RK_PB7 GPIO_ACTIVE_HIGH>;
 		BT,wake_host_irq = <&gpio2 RK_PB0 GPIO_ACTIVE_HIGH>;
-		status = "okay";
+		status = "disabled";
 	};
 
 	wireless-wlan {
@@ -39,8 +39,8 @@
 		rockchip,grf = <&grf>;
 		pinctrl-names = "default";
 		pinctrl-0 = <&wifi_wake_host>;
-		wifi_chip_type = "ap6256";
-		WIFI,host_wake_irq = <&gpio2 RK_PB4 GPIO_ACTIVE_HIGH>;
+		wifi_chip_type = "rtl8189fs";
+		WIFI,host_wake_irq = <&gpio4 RK_PB5 GPIO_ACTIVE_HIGH>;
 		status = "okay";
 	};
 };
@@ -49,10 +49,26 @@
 	status = "disabled";
 };
 
-&mac {
+&sdio {
+	bus-width = <4>;
+	cap-sd-highspeed;
+	supports-sdio;
+	ignore-pm-notify;
+	keep-power-in-suspend;
+	non-removable;
+	mmc-pwrseq = <&sdio_pwrseq>;
+	sd-uhs-sdr104;
 	status = "okay";
 };
 
+&sdmmc{
+	status = "disabled";
+};
+
+// &mac {
+// 	status = "okay";
+// };
+
 &vcc_ddr {
 	regulator-min-microvolt = <1350000>;
 	regulator-max-microvolt = <1350000>;
diff --git a/drivers/gpu/drm/panel/panel-simple-0.c b/drivers/gpu/drm/panel/panel-simple-0.c
new file mode 100644
index 000000000000..700ffd65c7c1
--- /dev/null
+++ b/drivers/gpu/drm/panel/panel-simple-0.c
@@ -0,0 +1,2460 @@
+/*
+ * Copyright (C) 2013, NVIDIA Corporation.  All rights reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sub license,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+#include <linux/backlight.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/of_platform.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/consumer.h>
+
+#include <drm/drmP.h>
+#include <drm/drm_crtc.h>
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_panel.h>
+
+#include <video/display_timing.h>
+#include <video/mipi_display.h>
+#include <linux/of_device.h>
+#include <video/of_display_timing.h>
+#include <linux/of_graph.h>
+#include <video/videomode.h>
+
+struct cmd_ctrl_hdr {
+	u8 dtype;	/* data type */
+	u8 wait;	/* ms */
+	u8 dlen;	/* payload len */
+} __packed;
+
+struct cmd_desc {
+	struct cmd_ctrl_hdr dchdr;
+	u8 *payload;
+};
+
+struct panel_cmds {
+	u8 *buf;
+	int blen;
+	struct cmd_desc *cmds;
+	int cmd_cnt;
+};
+
+struct panel_desc {
+	const struct drm_display_mode *modes;
+	unsigned int num_modes;
+	const struct display_timing *timings;
+	unsigned int num_timings;
+
+	unsigned int bpc;
+
+	struct {
+		unsigned int width;
+		unsigned int height;
+	} size;
+
+	/**
+	 * @reset: the time (in milliseconds) indicates the delay time
+	 *         after the panel to operate reset gpio
+	 * @init: the time (in milliseconds) that it takes for the panel to
+	 *           power on and dsi host can send command to panel
+	 * @prepare: the time (in milliseconds) that it takes for the panel to
+	 *           become ready and start receiving video data
+	 * @enable: the time (in milliseconds) that it takes for the panel to
+	 *          display the first valid frame after starting to receive
+	 *          video data
+	 * @disable: the time (in milliseconds) that it takes for the panel to
+	 *           turn the display off (no content is visible)
+	 * @unprepare: the time (in milliseconds) that it takes for the panel
+	 *             to power itself down completely
+	 */
+	struct {
+		unsigned int reset;
+		unsigned int init;
+		unsigned int prepare;
+		unsigned int enable;
+		unsigned int disable;
+		unsigned int unprepare;
+	} delay;
+
+	u32 bus_format;
+};
+
+struct panel_simple {
+	struct drm_panel base;
+	struct mipi_dsi_device *dsi;
+	bool prepared;
+	bool enabled;
+	bool power_invert;
+
+	struct device *dev;
+	const struct panel_desc *desc;
+
+	struct backlight_device *backlight;
+	struct regulator *supply;
+	struct i2c_adapter *ddc;
+
+	struct gpio_desc *enable_gpio;
+	struct gpio_desc *reset_gpio;
+	int cmd_type;
+
+	struct gpio_desc *spi_sdi_gpio;
+	struct gpio_desc *spi_scl_gpio;
+	struct gpio_desc *spi_cs_gpio;
+
+	struct panel_cmds *on_cmds;
+	struct panel_cmds *off_cmds;
+	struct device_node *np_crtc;
+};
+
+enum rockchip_cmd_type {
+	CMD_TYPE_DEFAULT,
+	CMD_TYPE_SPI,
+	CMD_TYPE_MCU
+};
+
+enum MCU_IOCTL {
+	MCU_WRCMD = 0,
+	MCU_WRDATA,
+	MCU_SETBYPASS,
+};
+
+static void panel_simple_sleep(unsigned int msec)
+{
+	if (msec > 20)
+		msleep(msec);
+	else
+		usleep_range(msec * 1000, (msec + 1) * 1000);
+}
+
+static inline int get_panel_cmd_type(const char *s)
+{
+	if (!s)
+		return -EINVAL;
+
+	if (strncmp(s, "spi", 3) == 0)
+		return CMD_TYPE_SPI;
+	else if (strncmp(s, "mcu", 3) == 0)
+		return CMD_TYPE_MCU;
+
+	return CMD_TYPE_DEFAULT;
+}
+
+static inline struct panel_simple *to_panel_simple(struct drm_panel *panel)
+{
+	return container_of(panel, struct panel_simple, base);
+}
+
+static void panel_simple_cmds_cleanup(struct panel_simple *p)
+{
+	if (p->on_cmds) {
+		kfree(p->on_cmds->buf);
+		kfree(p->on_cmds->cmds);
+	}
+
+	if (p->off_cmds) {
+		kfree(p->off_cmds->buf);
+		kfree(p->off_cmds->cmds);
+	}
+}
+
+static int panel_simple_parse_cmds(struct device *dev,
+				   const u8 *data, int blen,
+				   struct panel_cmds *pcmds)
+{
+	unsigned int len;
+	char *buf, *bp;
+	struct cmd_ctrl_hdr *dchdr;
+	int i, cnt;
+
+	if (!pcmds)
+		return -EINVAL;
+
+	buf = kmemdup(data, blen, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+
+	/* scan init commands */
+	bp = buf;
+	len = blen;
+	cnt = 0;
+	while (len > sizeof(*dchdr)) {
+		dchdr = (struct cmd_ctrl_hdr *)bp;
+
+		if (dchdr->dlen > len) {
+			dev_err(dev, "%s: error, len=%d", __func__,
+				dchdr->dlen);
+			return -EINVAL;
+		}
+
+		bp += sizeof(*dchdr);
+		len -= sizeof(*dchdr);
+		bp += dchdr->dlen;
+		len -= dchdr->dlen;
+		cnt++;
+	}
+
+	if (len != 0) {
+		dev_err(dev, "%s: dcs_cmd=%x len=%d error!",
+			__func__, buf[0], blen);
+		kfree(buf);
+		return -EINVAL;
+	}
+
+	pcmds->cmds = kcalloc(cnt, sizeof(struct cmd_desc), GFP_KERNEL);
+	if (!pcmds->cmds) {
+		kfree(buf);
+		return -ENOMEM;
+	}
+
+	pcmds->cmd_cnt = cnt;
+	pcmds->buf = buf;
+	pcmds->blen = blen;
+
+	bp = buf;
+	len = blen;
+	for (i = 0; i < cnt; i++) {
+		dchdr = (struct cmd_ctrl_hdr *)bp;
+		len -= sizeof(*dchdr);
+		bp += sizeof(*dchdr);
+		pcmds->cmds[i].dchdr = *dchdr;
+		pcmds->cmds[i].payload = bp;
+		bp += dchdr->dlen;
+		len -= dchdr->dlen;
+	}
+
+	return 0;
+}
+
+static void panel_simple_spi_write_cmd(struct panel_simple *panel,
+				       u8 type, int value)
+{
+	int i;
+
+	gpiod_direction_output(panel->spi_cs_gpio, 0);
+
+	if (type == 0)
+		value &= (~(1 << 8));
+	else
+		value |= (1 << 8);
+
+	for (i = 0; i < 9; i++) {
+		if (value & 0x100)
+			gpiod_direction_output(panel->spi_sdi_gpio, 1);
+		else
+			gpiod_direction_output(panel->spi_sdi_gpio, 0);
+
+		gpiod_direction_output(panel->spi_scl_gpio, 0);
+		udelay(10);
+		gpiod_direction_output(panel->spi_scl_gpio, 1);
+		value <<= 1;
+		udelay(10);
+	}
+
+	gpiod_direction_output(panel->spi_cs_gpio, 1);
+}
+
+static int panel_simple_mcu_send_cmds(struct panel_simple *panel,
+				      struct panel_cmds *cmds)
+{
+	int i;
+
+	if (!cmds)
+		return -EINVAL;
+
+	rockchip_drm_crtc_send_mcu_cmd(panel->base.drm,
+				       panel->np_crtc, MCU_SETBYPASS, 1);
+	for (i = 0; i < cmds->cmd_cnt; i++) {
+		struct cmd_desc *cmd = &cmds->cmds[i];
+		u32 value = 0;
+
+		value = cmd->payload[0];
+		rockchip_drm_crtc_send_mcu_cmd(panel->base.drm, panel->np_crtc,
+					       cmd->dchdr.dtype, value);
+		if (cmd->dchdr.wait)
+			panel_simple_sleep(cmd->dchdr.wait);
+	}
+	rockchip_drm_crtc_send_mcu_cmd(panel->base.drm,
+				       panel->np_crtc, MCU_SETBYPASS, 0);
+
+	return 0;
+}
+
+static int panel_simple_spi_send_cmds(struct panel_simple *panel,
+				      struct panel_cmds *cmds)
+{
+	int i;
+
+	if (!cmds)
+		return -EINVAL;
+
+	for (i = 0; i < cmds->cmd_cnt; i++) {
+		struct cmd_desc *cmd = &cmds->cmds[i];
+		int value = 0;
+
+		if (cmd->dchdr.dlen == 2)
+			value = (cmd->payload[0] << 8) | cmd->payload[1];
+		else
+			value = cmd->payload[0];
+		panel_simple_spi_write_cmd(panel, cmd->dchdr.dtype, value);
+
+		if (cmd->dchdr.wait)
+			panel_simple_sleep(cmd->dchdr.wait);
+	}
+
+	return 0;
+}
+
+#if IS_ENABLED(CONFIG_DRM_MIPI_DSI)
+static int panel_simple_dsi_send_cmds(struct panel_simple *panel,
+				      struct panel_cmds *cmds)
+{
+	struct mipi_dsi_device *dsi = panel->dsi;
+	int i, err;
+
+	if (!cmds)
+		return -EINVAL;
+
+	for (i = 0; i < cmds->cmd_cnt; i++) {
+		struct cmd_desc *cmd = &cmds->cmds[i];
+
+		switch (cmd->dchdr.dtype) {
+		case MIPI_DSI_GENERIC_SHORT_WRITE_0_PARAM:
+		case MIPI_DSI_GENERIC_SHORT_WRITE_1_PARAM:
+		case MIPI_DSI_GENERIC_SHORT_WRITE_2_PARAM:
+		case MIPI_DSI_GENERIC_LONG_WRITE:
+			err = mipi_dsi_generic_write(dsi, cmd->payload,
+						     cmd->dchdr.dlen);
+			break;
+		case MIPI_DSI_DCS_SHORT_WRITE:
+		case MIPI_DSI_DCS_SHORT_WRITE_PARAM:
+		case MIPI_DSI_DCS_LONG_WRITE:
+			err = mipi_dsi_dcs_write_buffer(dsi, cmd->payload,
+							cmd->dchdr.dlen);
+			break;
+		default:
+			return -EINVAL;
+		}
+
+		if (err < 0)
+			dev_err(panel->dev, "failed to write dcs cmd: %d\n",
+				err);
+
+		if (cmd->dchdr.wait)
+			panel_simple_sleep(cmd->dchdr.wait);
+	}
+
+	return 0;
+}
+#else
+static inline int panel_simple_dsi_send_cmds(struct panel_simple *panel,
+					     struct panel_cmds *cmds)
+{
+	return -EINVAL;
+}
+#endif
+
+static int panel_simple_get_cmds(struct panel_simple *panel)
+{
+	const void *data;
+	int len;
+	int err;
+
+	data = of_get_property(panel->dev->of_node, "panel-init-sequence",
+			       &len);
+	if (data) {
+		panel->on_cmds = devm_kzalloc(panel->dev,
+					      sizeof(*panel->on_cmds),
+					      GFP_KERNEL);
+		if (!panel->on_cmds)
+			return -ENOMEM;
+
+		err = panel_simple_parse_cmds(panel->dev, data, len,
+					      panel->on_cmds);
+		if (err) {
+			dev_err(panel->dev, "failed to parse panel init sequence\n");
+			return err;
+		}
+	}
+
+	data = of_get_property(panel->dev->of_node, "panel-exit-sequence",
+			       &len);
+	if (data) {
+		panel->off_cmds = devm_kzalloc(panel->dev,
+					       sizeof(*panel->off_cmds),
+					       GFP_KERNEL);
+		if (!panel->off_cmds)
+			return -ENOMEM;
+
+		err = panel_simple_parse_cmds(panel->dev, data, len,
+					      panel->off_cmds);
+		if (err) {
+			dev_err(panel->dev, "failed to parse panel exit sequence\n");
+			return err;
+		}
+	}
+	return 0;
+}
+
+static int panel_simple_get_fixed_modes(struct panel_simple *panel)
+{
+	struct drm_connector *connector = panel->base.connector;
+	struct drm_device *drm = panel->base.drm;
+	struct drm_display_mode *mode;
+	unsigned int i, num = 0;
+
+	if (!panel->desc)
+		return 0;
+
+	for (i = 0; i < panel->desc->num_timings; i++) {
+		const struct display_timing *dt = &panel->desc->timings[i];
+		struct videomode vm;
+
+		videomode_from_timing(dt, &vm);
+		mode = drm_mode_create(drm);
+		if (!mode) {
+			dev_err(drm->dev, "failed to add mode %ux%u\n",
+				dt->hactive.typ, dt->vactive.typ);
+			continue;
+		}
+
+		drm_display_mode_from_videomode(&vm, mode);
+		drm_mode_set_name(mode);
+
+		drm_mode_probed_add(connector, mode);
+		num++;
+	}
+
+	for (i = 0; i < panel->desc->num_modes; i++) {
+		const struct drm_display_mode *m = &panel->desc->modes[i];
+
+		mode = drm_mode_duplicate(drm, m);
+		if (!mode) {
+			dev_err(drm->dev, "failed to add mode %ux%u@%u\n",
+				m->hdisplay, m->vdisplay, m->vrefresh);
+			continue;
+		}
+
+		drm_mode_set_name(mode);
+
+		drm_mode_probed_add(connector, mode);
+		num++;
+	}
+
+	connector->display_info.bpc = panel->desc->bpc;
+	connector->display_info.width_mm = panel->desc->size.width;
+	connector->display_info.height_mm = panel->desc->size.height;
+	if (panel->desc->bus_format)
+		drm_display_info_set_bus_formats(&connector->display_info,
+						 &panel->desc->bus_format, 1);
+
+	return num;
+}
+
+static int panel_simple_of_get_native_mode(struct panel_simple *panel)
+{
+	struct drm_connector *connector = panel->base.connector;
+	struct drm_device *drm = panel->base.drm;
+	struct drm_display_mode *mode;
+	struct device_node *timings_np;
+	int ret;
+
+	timings_np = of_get_child_by_name(panel->dev->of_node,
+					  "display-timings");
+	if (!timings_np) {
+		dev_dbg(panel->dev, "failed to find display-timings node\n");
+		return 0;
+	}
+
+	of_node_put(timings_np);
+	mode = drm_mode_create(drm);
+	if (!mode)
+		return 0;
+
+	ret = of_get_drm_display_mode(panel->dev->of_node, mode,
+				      OF_USE_NATIVE_MODE);
+	if (ret) {
+		dev_dbg(panel->dev, "failed to find dts display timings\n");
+		drm_mode_destroy(drm, mode);
+		return 0;
+	}
+
+	drm_mode_set_name(mode);
+	mode->type |= DRM_MODE_TYPE_PREFERRED;
+	drm_mode_probed_add(connector, mode);
+
+	return 1;
+}
+
+static int panel_simple_regulator_enable(struct drm_panel *panel)
+{
+	struct panel_simple *p = to_panel_simple(panel);
+	int err = 0;
+
+	if (p->power_invert) {
+		if (regulator_is_enabled(p->supply) > 0)
+			regulator_disable(p->supply);
+	} else {
+		err = regulator_enable(p->supply);
+		if (err < 0) {
+			dev_err(panel->dev, "failed to enable supply: %d\n",
+				err);
+			return err;
+		}
+	}
+
+	return err;
+}
+
+static int panel_simple_regulator_disable(struct drm_panel *panel)
+{
+	struct panel_simple *p = to_panel_simple(panel);
+	int err = 0;
+
+	if (p->power_invert) {
+		if (!regulator_is_enabled(p->supply)) {
+			err = regulator_enable(p->supply);
+			if (err < 0) {
+				dev_err(panel->dev, "failed to enable supply: %d\n",
+					err);
+				return err;
+			}
+		}
+	} else {
+		regulator_disable(p->supply);
+	}
+
+	return err;
+}
+
+static int panel_simple_loader_protect(struct drm_panel *panel, bool on)
+{
+	int err;
+
+	if (on) {
+		err = panel_simple_regulator_enable(panel);
+		if (err < 0) {
+			dev_err(panel->dev, "failed to enable supply: %d\n",
+				err);
+			return err;
+		}
+	} else {
+		panel_simple_regulator_disable(panel);
+	}
+
+	return 0;
+}
+
+static int panel_simple_disable(struct drm_panel *panel)
+{
+	struct panel_simple *p = to_panel_simple(panel);
+	int err = 0;
+
+	if (!p->enabled)
+		return 0;
+
+	if (p->backlight) {
+		p->backlight->props.power = FB_BLANK_POWERDOWN;
+		backlight_update_status(p->backlight);
+	}
+
+	if (p->desc && p->desc->delay.disable)
+		panel_simple_sleep(p->desc->delay.disable);
+
+	if (p->cmd_type == CMD_TYPE_MCU) {
+		err = panel_simple_mcu_send_cmds(p, p->off_cmds);
+		if (err)
+			dev_err(p->dev, "failed to send mcu off cmds\n");
+	}
+	p->enabled = false;
+
+	return 0;
+}
+
+static int panel_simple_unprepare(struct drm_panel *panel)
+{
+	struct panel_simple *p = to_panel_simple(panel);
+	int err = 0;
+
+	if (!p->prepared)
+		return 0;
+
+	if (p->off_cmds) {
+		if (p->dsi)
+			err = panel_simple_dsi_send_cmds(p, p->off_cmds);
+		else if (p->cmd_type == CMD_TYPE_SPI)
+			err = panel_simple_spi_send_cmds(p, p->off_cmds);
+		if (err)
+			dev_err(p->dev, "failed to send off cmds\n");
+	}
+
+	if (p->reset_gpio)
+		gpiod_direction_output(p->reset_gpio, 1);
+
+	if (p->enable_gpio)
+		gpiod_direction_output(p->enable_gpio, 0);
+
+	panel_simple_regulator_disable(panel);
+
+	if (p->desc && p->desc->delay.unprepare)
+		panel_simple_sleep(p->desc->delay.unprepare);
+
+	p->prepared = false;
+
+	return 0;
+}
+
+static int panel_simple_prepare(struct drm_panel *panel)
+{
+	struct panel_simple *p = to_panel_simple(panel);
+	int err;
+
+	if (p->prepared)
+		return 0;
+
+	err = panel_simple_regulator_enable(panel);
+	if (err < 0) {
+		dev_err(panel->dev, "failed to enable supply: %d\n", err);
+		return err;
+	}
+
+	if (p->enable_gpio)
+		gpiod_direction_output(p->enable_gpio, 1);
+
+	if (p->desc && p->desc->delay.prepare)
+		panel_simple_sleep(p->desc->delay.prepare);
+
+	if (p->reset_gpio)
+		gpiod_direction_output(p->reset_gpio, 1);
+
+	if (p->desc && p->desc->delay.reset)
+		panel_simple_sleep(p->desc->delay.reset);
+
+	if (p->reset_gpio)
+		gpiod_direction_output(p->reset_gpio, 0);
+
+	if (p->desc && p->desc->delay.init)
+		panel_simple_sleep(p->desc->delay.init);
+
+	if (p->on_cmds) {
+		if (p->dsi)
+			err = panel_simple_dsi_send_cmds(p, p->on_cmds);
+		else if (p->cmd_type == CMD_TYPE_SPI)
+			err = panel_simple_spi_send_cmds(p, p->on_cmds);
+		if (err)
+			dev_err(p->dev, "failed to send on cmds\n");
+	}
+
+	p->prepared = true;
+
+	return 0;
+}
+
+static int panel_simple_enable(struct drm_panel *panel)
+{
+	struct panel_simple *p = to_panel_simple(panel);
+	int err = 0;
+
+	if (p->enabled)
+		return 0;
+
+	if (p->cmd_type == CMD_TYPE_MCU) {
+		err = panel_simple_mcu_send_cmds(p, p->on_cmds);
+		if (err)
+			dev_err(p->dev, "failed to send mcu on cmds\n");
+	}
+	if (p->desc && p->desc->delay.enable)
+		panel_simple_sleep(p->desc->delay.enable);
+
+	if (p->backlight) {
+		p->backlight->props.power = FB_BLANK_UNBLANK;
+		backlight_update_status(p->backlight);
+	}
+
+	p->enabled = true;
+
+	return 0;
+}
+
+static int panel_simple_get_modes(struct drm_panel *panel)
+{
+	struct panel_simple *p = to_panel_simple(panel);
+	int num = 0;
+
+	/* add device node plane modes */
+	num += panel_simple_of_get_native_mode(p);
+
+	/* add hard-coded panel modes */
+	num += panel_simple_get_fixed_modes(p);
+
+	/* probe EDID if a DDC bus is available */
+	if (p->ddc) {
+		struct edid *edid = drm_get_edid(panel->connector, p->ddc);
+		drm_mode_connector_update_edid_property(panel->connector, edid);
+		if (edid) {
+			num += drm_add_edid_modes(panel->connector, edid);
+			kfree(edid);
+		}
+	}
+
+	return num;
+}
+
+static int panel_simple_get_timings(struct drm_panel *panel,
+				    unsigned int num_timings,
+				    struct display_timing *timings)
+{
+	struct panel_simple *p = to_panel_simple(panel);
+	unsigned int i;
+
+	if (!p->desc)
+		return 0;
+
+	if (p->desc->num_timings < num_timings)
+		num_timings = p->desc->num_timings;
+
+	if (timings)
+		for (i = 0; i < num_timings; i++)
+			timings[i] = p->desc->timings[i];
+
+	return p->desc->num_timings;
+}
+
+static const struct drm_panel_funcs panel_simple_funcs = {
+	.loader_protect = panel_simple_loader_protect,
+	.disable = panel_simple_disable,
+	.unprepare = panel_simple_unprepare,
+	.prepare = panel_simple_prepare,
+	.enable = panel_simple_enable,
+	.get_modes = panel_simple_get_modes,
+	.get_timings = panel_simple_get_timings,
+};
+
+static int panel_simple_probe(struct device *dev, const struct panel_desc *desc)
+{
+	struct device_node *backlight, *ddc;
+	struct panel_simple *panel;
+	struct panel_desc *of_desc;
+	const char *cmd_type;
+	u32 val;
+	int err;
+
+	panel = devm_kzalloc(dev, sizeof(*panel), GFP_KERNEL);
+	if (!panel)
+		return -ENOMEM;
+
+	if (!desc)
+		of_desc = devm_kzalloc(dev, sizeof(*of_desc), GFP_KERNEL);
+	else
+		of_desc = devm_kmemdup(dev, desc, sizeof(*of_desc), GFP_KERNEL);
+
+	if (!of_property_read_u32(dev->of_node, "bus-format", &val))
+		of_desc->bus_format = val;
+	if (!of_property_read_u32(dev->of_node, "bpc", &val))
+		of_desc->bpc = val;
+	if (!of_property_read_u32(dev->of_node, "prepare-delay-ms", &val))
+		of_desc->delay.prepare = val;
+	if (!of_property_read_u32(dev->of_node, "enable-delay-ms", &val))
+		of_desc->delay.enable = val;
+	if (!of_property_read_u32(dev->of_node, "disable-delay-ms", &val))
+		of_desc->delay.disable = val;
+	if (!of_property_read_u32(dev->of_node, "unprepare-delay-ms", &val))
+		of_desc->delay.unprepare = val;
+	if (!of_property_read_u32(dev->of_node, "reset-delay-ms", &val))
+		of_desc->delay.reset = val;
+	if (!of_property_read_u32(dev->of_node, "init-delay-ms", &val))
+		of_desc->delay.init = val;
+	if (!of_property_read_u32(dev->of_node, "width-mm", &val))
+		of_desc->size.width = val;
+	if (!of_property_read_u32(dev->of_node, "height-mm", &val))
+		of_desc->size.height = val;
+
+	panel->enabled = false;
+	panel->prepared = false;
+	panel->desc = of_desc;
+	panel->dev = dev;
+
+	err = panel_simple_get_cmds(panel);
+	if (err) {
+		dev_err(dev, "failed to get init cmd: %d\n", err);
+		return err;
+	}
+	panel->supply = devm_regulator_get(dev, "power");
+	if (IS_ERR(panel->supply))
+		return PTR_ERR(panel->supply);
+
+	panel->enable_gpio = devm_gpiod_get_optional(dev, "enable", 0);
+	if (IS_ERR(panel->enable_gpio)) {
+		err = PTR_ERR(panel->enable_gpio);
+		dev_err(dev, "failed to request enable GPIO: %d\n", err);
+		return err;
+	}
+
+	panel->reset_gpio = devm_gpiod_get_optional(dev, "reset", 0);
+	if (IS_ERR(panel->reset_gpio)) {
+		err = PTR_ERR(panel->reset_gpio);
+		dev_err(dev, "failed to request reset GPIO: %d\n", err);
+		return err;
+	}
+
+	if (of_property_read_string(dev->of_node, "rockchip,cmd-type",
+				    &cmd_type))
+		panel->cmd_type = CMD_TYPE_DEFAULT;
+	else
+		panel->cmd_type = get_panel_cmd_type(cmd_type);
+
+	if (panel->cmd_type == CMD_TYPE_SPI) {
+		panel->spi_sdi_gpio =
+				devm_gpiod_get_optional(dev, "spi-sdi", 0);
+		if (IS_ERR(panel->spi_sdi_gpio)) {
+			err = PTR_ERR(panel->spi_sdi_gpio);
+			dev_err(dev, "failed to request spi_sdi: %d\n", err);
+			return err;
+		}
+
+		panel->spi_scl_gpio =
+				devm_gpiod_get_optional(dev, "spi-scl", 0);
+		if (IS_ERR(panel->spi_scl_gpio)) {
+			err = PTR_ERR(panel->spi_scl_gpio);
+			dev_err(dev, "failed to request spi_scl: %d\n", err);
+			return err;
+		}
+
+		panel->spi_cs_gpio = devm_gpiod_get_optional(dev, "spi-cs", 0);
+		if (IS_ERR(panel->spi_cs_gpio)) {
+			err = PTR_ERR(panel->spi_cs_gpio);
+			dev_err(dev, "failed to request spi_cs: %d\n", err);
+			return err;
+		}
+		gpiod_direction_output(panel->spi_cs_gpio, 1);
+		gpiod_direction_output(panel->spi_sdi_gpio, 1);
+		gpiod_direction_output(panel->spi_scl_gpio, 1);
+	} else if (panel->cmd_type == CMD_TYPE_MCU) {
+		struct device_node *port, *endpoint;
+		struct device_node *np;
+
+		port = of_graph_get_port_by_id(dev->of_node, 0);
+		if (port) {
+			endpoint = of_get_next_child(port, NULL);
+			/* get connect device node */
+			np = of_graph_get_remote_port_parent(endpoint);
+
+			port = of_graph_get_port_by_id(np, 0);
+			if (port) {
+				endpoint = of_get_next_child(port, NULL);
+				/* get crtc device node */
+				np = of_graph_get_remote_port_parent(endpoint);
+				panel->np_crtc = np;
+			}
+		}
+	}
+	panel->power_invert =
+			of_property_read_bool(dev->of_node, "power-invert");
+
+	backlight = of_parse_phandle(dev->of_node, "backlight", 0);
+	if (backlight) {
+		panel->backlight = of_find_backlight_by_node(backlight);
+		of_node_put(backlight);
+
+		if (!panel->backlight)
+			return -EPROBE_DEFER;
+	}
+
+	ddc = of_parse_phandle(dev->of_node, "ddc-i2c-bus", 0);
+	if (ddc) {
+		panel->ddc = of_find_i2c_adapter_by_node(ddc);
+		of_node_put(ddc);
+
+		if (!panel->ddc) {
+			err = -EPROBE_DEFER;
+			goto free_backlight;
+		}
+	}
+
+	drm_panel_init(&panel->base);
+	panel->base.dev = dev;
+	panel->base.funcs = &panel_simple_funcs;
+
+	err = drm_panel_add(&panel->base);
+	if (err < 0)
+		goto free_ddc;
+
+	dev_set_drvdata(dev, panel);
+
+	return 0;
+
+free_ddc:
+	if (panel->ddc)
+		put_device(&panel->ddc->dev);
+free_backlight:
+	if (panel->backlight)
+		put_device(&panel->backlight->dev);
+
+	return err;
+}
+
+static int panel_simple_remove(struct device *dev)
+{
+	struct panel_simple *panel = dev_get_drvdata(dev);
+
+	drm_panel_detach(&panel->base);
+	drm_panel_remove(&panel->base);
+
+	panel_simple_disable(&panel->base);
+	panel_simple_unprepare(&panel->base);
+
+	if (panel->ddc)
+		put_device(&panel->ddc->dev);
+
+	if (panel->backlight)
+		put_device(&panel->backlight->dev);
+
+	panel_simple_cmds_cleanup(panel);
+
+	return 0;
+}
+
+static void panel_simple_shutdown(struct device *dev)
+{
+	struct panel_simple *panel = dev_get_drvdata(dev);
+
+	panel_simple_disable(&panel->base);
+
+	if (panel->reset_gpio)
+		gpiod_direction_output(panel->reset_gpio, 1);
+
+	if (panel->enable_gpio)
+		gpiod_direction_output(panel->enable_gpio, 0);
+
+	panel_simple_regulator_disable(&panel->base);
+}
+
+static const struct drm_display_mode ampire_am800480r3tmqwa1h_mode = {
+	.clock = 33333,
+	.hdisplay = 800,
+	.hsync_start = 800 + 0,
+	.hsync_end = 800 + 0 + 255,
+	.htotal = 800 + 0 + 255 + 0,
+	.vdisplay = 480,
+	.vsync_start = 480 + 2,
+	.vsync_end = 480 + 2 + 45,
+	.vtotal = 480 + 2 + 45 + 0,
+	.vrefresh = 60,
+	.flags = DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC,
+};
+
+static const struct panel_desc ampire_am800480r3tmqwa1h = {
+	.modes = &ampire_am800480r3tmqwa1h_mode,
+	.num_modes = 1,
+	.bpc = 6,
+	.size = {
+		.width = 152,
+		.height = 91,
+	},
+	.bus_format = MEDIA_BUS_FMT_RGB666_1X18,
+};
+
+static const struct drm_display_mode auo_b101aw03_mode = {
+	.clock = 51450,
+	.hdisplay = 1024,
+	.hsync_start = 1024 + 156,
+	.hsync_end = 1024 + 156 + 8,
+	.htotal = 1024 + 156 + 8 + 156,
+	.vdisplay = 600,
+	.vsync_start = 600 + 16,
+	.vsync_end = 600 + 16 + 6,
+	.vtotal = 600 + 16 + 6 + 16,
+	.vrefresh = 60,
+};
+
+static const struct panel_desc auo_b101aw03 = {
+	.modes = &auo_b101aw03_mode,
+	.num_modes = 1,
+	.bpc = 6,
+	.size = {
+		.width = 223,
+		.height = 125,
+	},
+};
+
+static const struct drm_display_mode auo_b101ean01_mode = {
+	.clock = 72500,
+	.hdisplay = 1280,
+	.hsync_start = 1280 + 119,
+	.hsync_end = 1280 + 119 + 32,
+	.htotal = 1280 + 119 + 32 + 21,
+	.vdisplay = 800,
+	.vsync_start = 800 + 4,
+	.vsync_end = 800 + 4 + 20,
+	.vtotal = 800 + 4 + 20 + 8,
+	.vrefresh = 60,
+};
+
+static const struct panel_desc auo_b101ean01 = {
+	.modes = &auo_b101ean01_mode,
+	.num_modes = 1,
+	.bpc = 6,
+	.size = {
+		.width = 217,
+		.height = 136,
+	},
+};
+
+static const struct drm_display_mode auo_b101ew05_mode = {
+	.clock = 71000,
+	.hdisplay = 1280,
+	.hsync_start = 1280 + 18,
+	.hsync_end = 1280 + 18 + 10,
+	.htotal = 1280 + 18 + 10 + 100,
+	.vdisplay = 800,
+	.vsync_start = 800 + 6,
+	.vsync_end = 800 + 6 + 2,
+	.vtotal = 800 + 6 + 2 + 8,
+	.vrefresh = 60,
+};
+
+static const struct panel_desc auo_b101ew05 = {
+	.modes = &auo_b101ew05_mode,
+	.num_modes = 1,
+	.bpc = 6,
+	.size = {
+		.width = 217,
+		.height = 136,
+	},
+};
+
+static const struct drm_display_mode auo_b101xtn01_mode = {
+	.clock = 72000,
+	.hdisplay = 1366,
+	.hsync_start = 1366 + 20,
+	.hsync_end = 1366 + 20 + 70,
+	.htotal = 1366 + 20 + 70,
+	.vdisplay = 768,
+	.vsync_start = 768 + 14,
+	.vsync_end = 768 + 14 + 42,
+	.vtotal = 768 + 14 + 42,
+	.vrefresh = 60,
+	.flags = DRM_MODE_FLAG_NVSYNC | DRM_MODE_FLAG_NHSYNC,
+};
+
+static const struct panel_desc auo_b101xtn01 = {
+	.modes = &auo_b101xtn01_mode,
+	.num_modes = 1,
+	.bpc = 6,
+	.size = {
+		.width = 223,
+		.height = 125,
+	},
+};
+
+static const struct drm_display_mode auo_b116xw03_mode = {
+	.clock = 70589,
+	.hdisplay = 1366,
+	.hsync_start = 1366 + 40,
+	.hsync_end = 1366 + 40 + 40,
+	.htotal = 1366 + 40 + 40 + 32,
+	.vdisplay = 768,
+	.vsync_start = 768 + 10,
+	.vsync_end = 768 + 10 + 12,
+	.vtotal = 768 + 10 + 12 + 6,
+	.vrefresh = 60,
+};
+
+static const struct panel_desc auo_b116xw03 = {
+	.modes = &auo_b116xw03_mode,
+	.num_modes = 1,
+	.bpc = 6,
+	.size = {
+		.width = 256,
+		.height = 144,
+	},
+};
+
+static const struct drm_display_mode auo_b125han03_mode = {
+	.clock = 146900,
+	.hdisplay = 1920,
+	.hsync_start = 1920 + 48,
+	.hsync_end = 1920 + 48 + 32,
+	.htotal = 1920 + 48 + 32 + 140,
+	.vdisplay = 1080,
+	.vsync_start = 1080 + 2,
+	.vsync_end = 1080 + 2 + 5,
+	.vtotal = 1080 + 2 + 5 + 57,
+	.vrefresh = 60,
+	.flags = DRM_MODE_FLAG_NVSYNC | DRM_MODE_FLAG_NHSYNC,
+};
+
+static const struct panel_desc auo_b125han03 = {
+	.modes = &auo_b125han03_mode,
+	.num_modes = 1,
+	.bpc = 6,
+	.size = {
+		.width = 276,
+		.height = 156,
+	},
+	.bus_format = MEDIA_BUS_FMT_RGB666_1X18,
+};
+
+static const struct drm_display_mode auo_b133xtn01_mode = {
+	.clock = 69500,
+	.hdisplay = 1366,
+	.hsync_start = 1366 + 48,
+	.hsync_end = 1366 + 48 + 32,
+	.htotal = 1366 + 48 + 32 + 20,
+	.vdisplay = 768,
+	.vsync_start = 768 + 3,
+	.vsync_end = 768 + 3 + 6,
+	.vtotal = 768 + 3 + 6 + 13,
+	.vrefresh = 60,
+};
+
+static const struct panel_desc auo_b133xtn01 = {
+	.modes = &auo_b133xtn01_mode,
+	.num_modes = 1,
+	.bpc = 6,
+	.size = {
+		.width = 293,
+		.height = 165,
+	},
+};
+
+static const struct drm_display_mode auo_b133htn01_mode = {
+	.clock = 150660,
+	.hdisplay = 1920,
+	.hsync_start = 1920 + 172,
+	.hsync_end = 1920 + 172 + 80,
+	.htotal = 1920 + 172 + 80 + 60,
+	.vdisplay = 1080,
+	.vsync_start = 1080 + 25,
+	.vsync_end = 1080 + 25 + 10,
+	.vtotal = 1080 + 25 + 10 + 10,
+	.vrefresh = 60,
+};
+
+static const struct panel_desc auo_b133htn01 = {
+	.modes = &auo_b133htn01_mode,
+	.num_modes = 1,
+	.bpc = 6,
+	.size = {
+		.width = 293,
+		.height = 165,
+	},
+	.delay = {
+		.prepare = 105,
+		.enable = 20,
+		.unprepare = 50,
+	},
+};
+
+static const struct drm_display_mode avic_tm070ddh03_mode = {
+	.clock = 51200,
+	.hdisplay = 1024,
+	.hsync_start = 1024 + 160,
+	.hsync_end = 1024 + 160 + 4,
+	.htotal = 1024 + 160 + 4 + 156,
+	.vdisplay = 600,
+	.vsync_start = 600 + 17,
+	.vsync_end = 600 + 17 + 1,
+	.vtotal = 600 + 17 + 1 + 17,
+	.vrefresh = 60,
+};
+
+static const struct panel_desc avic_tm070ddh03 = {
+	.modes = &avic_tm070ddh03_mode,
+	.num_modes = 1,
+	.bpc = 8,
+	.size = {
+		.width = 154,
+		.height = 90,
+	},
+	.delay = {
+		.prepare = 20,
+		.enable = 200,
+		.disable = 200,
+	},
+};
+
+static const struct drm_display_mode boe_mv238qum_n20_mode = {
+	.clock = 559440,
+	.hdisplay = 3840,
+	.hsync_start = 3840 + 150,
+	.hsync_end = 3840 + 150 + 60,
+	.htotal = 3840 + 150 + 60 + 150,
+	.vdisplay = 2160,
+	.vsync_start = 2160 + 24,
+	.vsync_end = 2160 + 24 + 12,
+	.vtotal = 2160 + 24 + 12 + 24,
+	.vrefresh = 60,
+	.flags = DRM_MODE_FLAG_NVSYNC | DRM_MODE_FLAG_NHSYNC,
+};
+
+static const struct panel_desc boe_mv238qum_n20 = {
+	.modes = &boe_mv238qum_n20_mode,
+	.num_modes = 1,
+	.bpc = 8,
+	.size = {
+		.width = 527,
+		.height = 296,
+	},
+	.delay = {
+		.prepare = 20,
+		.enable = 20,
+		.unprepare = 20,
+		.disable = 20,
+	},
+};
+
+static const struct drm_display_mode boe_mv270qum_n10_mode = {
+	.clock = 533000,
+	.hdisplay = 3840,
+	.hsync_start = 3840 + 78,
+	.hsync_end = 3840 + 78 + 28,
+	.htotal = 3840 + 78 + 28 + 54,
+	.vdisplay = 2160,
+	.vsync_start = 2160 + 47,
+	.vsync_end = 2160 + 47 + 8,
+	.vtotal = 2160 + 47 + 8 + 7,
+	.vrefresh = 60,
+	.flags = DRM_MODE_FLAG_NVSYNC | DRM_MODE_FLAG_NHSYNC,
+};
+
+static const struct panel_desc boe_mv270qum_n10 = {
+	.modes = &boe_mv270qum_n10_mode,
+	.num_modes = 1,
+	.bpc = 8,
+	.size = {
+		.width = 597,
+		.height = 336,
+	},
+};
+
+static const struct drm_display_mode boe_nv125fhm_n73_mode = {
+	.clock = 72300,
+	.hdisplay = 1366,
+	.hsync_start = 1366 + 80,
+	.hsync_end = 1366 + 80 + 20,
+	.htotal = 1366 + 80 + 20 + 60,
+	.vdisplay = 768,
+	.vsync_start = 768 + 12,
+	.vsync_end = 768 + 12 + 2,
+	.vtotal = 768 + 12 + 2 + 8,
+	.vrefresh = 60,
+	.flags = DRM_MODE_FLAG_NVSYNC | DRM_MODE_FLAG_NHSYNC,
+};
+
+static const struct panel_desc boe_nv125fhm_n73 = {
+	.modes = &boe_nv125fhm_n73_mode,
+	.num_modes = 1,
+	.bpc = 6,
+	.size = {
+		.width = 276,
+		.height = 156,
+	},
+	.delay = {
+		.unprepare = 160,
+	},
+	.bus_format = MEDIA_BUS_FMT_RGB666_1X18,
+};
+
+static const struct drm_display_mode chunghwa_claa070wp03xg_mode = {
+	.clock = 67000,
+	.hdisplay = 800,
+	.hsync_start = 800 + 24,
+	.hsync_end = 800 + 24 + 16,
+	.htotal = 800 + 24 + 16 + 24,
+	.vdisplay = 1280,
+	.vsync_start = 1280 + 2,
+	.vsync_end = 1280 + 2 + 2,
+	.vtotal = 1280 + 2 + 2 + 4,
+	.vrefresh = 60,
+};
+
+static const struct panel_desc chunghwa_claa070wp03xg = {
+	.modes = &chunghwa_claa070wp03xg_mode,
+	.num_modes = 1,
+	.bpc = 6,
+	.size = {
+		.width = 94,
+		.height = 151,
+	},
+};
+
+static const struct drm_display_mode chunghwa_claa101wa01a_mode = {
+	.clock = 72070,
+	.hdisplay = 1366,
+	.hsync_start = 1366 + 58,
+	.hsync_end = 1366 + 58 + 58,
+	.htotal = 1366 + 58 + 58 + 58,
+	.vdisplay = 768,
+	.vsync_start = 768 + 4,
+	.vsync_end = 768 + 4 + 4,
+	.vtotal = 768 + 4 + 4 + 4,
+	.vrefresh = 60,
+};
+
+static const struct panel_desc chunghwa_claa101wa01a = {
+	.modes = &chunghwa_claa101wa01a_mode,
+	.num_modes = 1,
+	.bpc = 6,
+	.size = {
+		.width = 220,
+		.height = 120,
+	},
+};
+
+static const struct drm_display_mode chunghwa_claa101wb01_mode = {
+	.clock = 69300,
+	.hdisplay = 1366,
+	.hsync_start = 1366 + 48,
+	.hsync_end = 1366 + 48 + 32,
+	.htotal = 1366 + 48 + 32 + 20,
+	.vdisplay = 768,
+	.vsync_start = 768 + 16,
+	.vsync_end = 768 + 16 + 8,
+	.vtotal = 768 + 16 + 8 + 16,
+	.vrefresh = 60,
+};
+
+static const struct panel_desc chunghwa_claa101wb01 = {
+	.modes = &chunghwa_claa101wb01_mode,
+	.num_modes = 1,
+	.bpc = 6,
+	.size = {
+		.width = 223,
+		.height = 125,
+	},
+};
+
+static const struct drm_display_mode edt_et057090dhu_mode = {
+	.clock = 25175,
+	.hdisplay = 640,
+	.hsync_start = 640 + 16,
+	.hsync_end = 640 + 16 + 30,
+	.htotal = 640 + 16 + 30 + 114,
+	.vdisplay = 480,
+	.vsync_start = 480 + 10,
+	.vsync_end = 480 + 10 + 3,
+	.vtotal = 480 + 10 + 3 + 32,
+	.vrefresh = 60,
+	.flags = DRM_MODE_FLAG_NVSYNC | DRM_MODE_FLAG_NHSYNC,
+};
+
+static const struct panel_desc edt_et057090dhu = {
+	.modes = &edt_et057090dhu_mode,
+	.num_modes = 1,
+	.bpc = 6,
+	.size = {
+		.width = 115,
+		.height = 86,
+	},
+};
+
+static const struct drm_display_mode edt_etm0700g0dh6_mode = {
+	.clock = 33260,
+	.hdisplay = 800,
+	.hsync_start = 800 + 40,
+	.hsync_end = 800 + 40 + 128,
+	.htotal = 800 + 40 + 128 + 88,
+	.vdisplay = 480,
+	.vsync_start = 480 + 10,
+	.vsync_end = 480 + 10 + 2,
+	.vtotal = 480 + 10 + 2 + 33,
+	.vrefresh = 60,
+	.flags = DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC,
+};
+
+static const struct panel_desc edt_etm0700g0dh6 = {
+	.modes = &edt_etm0700g0dh6_mode,
+	.num_modes = 1,
+	.bpc = 6,
+	.size = {
+		.width = 152,
+		.height = 91,
+	},
+};
+
+static const struct drm_display_mode foxlink_fl500wvr00_a0t_mode = {
+	.clock = 32260,
+	.hdisplay = 800,
+	.hsync_start = 800 + 168,
+	.hsync_end = 800 + 168 + 64,
+	.htotal = 800 + 168 + 64 + 88,
+	.vdisplay = 480,
+	.vsync_start = 480 + 37,
+	.vsync_end = 480 + 37 + 2,
+	.vtotal = 480 + 37 + 2 + 8,
+	.vrefresh = 60,
+};
+
+static const struct panel_desc foxlink_fl500wvr00_a0t = {
+	.modes = &foxlink_fl500wvr00_a0t_mode,
+	.num_modes = 1,
+	.bpc = 8,
+	.size = {
+		.width = 108,
+		.height = 65,
+	},
+	.bus_format = MEDIA_BUS_FMT_RGB888_1X24,
+};
+
+static const struct drm_display_mode giantplus_gpg482739qs5_mode = {
+	.clock = 9000,
+	.hdisplay = 480,
+	.hsync_start = 480 + 5,
+	.hsync_end = 480 + 5 + 1,
+	.htotal = 480 + 5 + 1 + 40,
+	.vdisplay = 272,
+	.vsync_start = 272 + 8,
+	.vsync_end = 272 + 8 + 1,
+	.vtotal = 272 + 8 + 1 + 8,
+	.vrefresh = 60,
+};
+
+static const struct panel_desc giantplus_gpg482739qs5 = {
+	.modes = &giantplus_gpg482739qs5_mode,
+	.num_modes = 1,
+	.bpc = 8,
+	.size = {
+		.width = 95,
+		.height = 54,
+	},
+	.bus_format = MEDIA_BUS_FMT_RGB888_1X24,
+};
+
+static const struct display_timing hannstar_hsd070pww1_timing = {
+	.pixelclock = { 64300000, 71100000, 82000000 },
+	.hactive = { 1280, 1280, 1280 },
+	.hfront_porch = { 1, 1, 10 },
+	.hback_porch = { 1, 1, 10 },
+	/*
+	 * According to the data sheet, the minimum horizontal blanking interval
+	 * is 54 clocks (1 + 52 + 1), but tests with a Nitrogen6X have shown the
+	 * minimum working horizontal blanking interval to be 60 clocks.
+	 */
+	.hsync_len = { 58, 158, 661 },
+	.vactive = { 800, 800, 800 },
+	.vfront_porch = { 1, 1, 10 },
+	.vback_porch = { 1, 1, 10 },
+	.vsync_len = { 1, 21, 203 },
+	.flags = DISPLAY_FLAGS_DE_HIGH,
+};
+
+static const struct panel_desc hannstar_hsd070pww1 = {
+	.timings = &hannstar_hsd070pww1_timing,
+	.num_timings = 1,
+	.bpc = 6,
+	.size = {
+		.width = 151,
+		.height = 94,
+	},
+	.bus_format = MEDIA_BUS_FMT_RGB666_1X7X3_SPWG,
+};
+
+static const struct display_timing hannstar_hsd100pxn1_timing = {
+	.pixelclock = { 55000000, 65000000, 75000000 },
+	.hactive = { 1024, 1024, 1024 },
+	.hfront_porch = { 40, 40, 40 },
+	.hback_porch = { 220, 220, 220 },
+	.hsync_len = { 20, 60, 100 },
+	.vactive = { 768, 768, 768 },
+	.vfront_porch = { 7, 7, 7 },
+	.vback_porch = { 21, 21, 21 },
+	.vsync_len = { 10, 10, 10 },
+	.flags = DISPLAY_FLAGS_DE_HIGH,
+};
+
+static const struct panel_desc hannstar_hsd100pxn1 = {
+	.timings = &hannstar_hsd100pxn1_timing,
+	.num_timings = 1,
+	.bpc = 6,
+	.size = {
+		.width = 203,
+		.height = 152,
+	},
+	.bus_format = MEDIA_BUS_FMT_RGB666_1X7X3_SPWG,
+};
+
+static const struct drm_display_mode hitachi_tx23d38vm0caa_mode = {
+	.clock = 33333,
+	.hdisplay = 800,
+	.hsync_start = 800 + 85,
+	.hsync_end = 800 + 85 + 86,
+	.htotal = 800 + 85 + 86 + 85,
+	.vdisplay = 480,
+	.vsync_start = 480 + 16,
+	.vsync_end = 480 + 16 + 13,
+	.vtotal = 480 + 16 + 13 + 16,
+	.vrefresh = 60,
+};
+
+static const struct panel_desc hitachi_tx23d38vm0caa = {
+	.modes = &hitachi_tx23d38vm0caa_mode,
+	.num_modes = 1,
+	.bpc = 6,
+	.size = {
+		.width = 195,
+		.height = 117,
+	},
+};
+
+static const struct drm_display_mode innolux_at043tn24_mode = {
+	.clock = 9000,
+	.hdisplay = 480,
+	.hsync_start = 480 + 2,
+	.hsync_end = 480 + 2 + 41,
+	.htotal = 480 + 2 + 41 + 2,
+	.vdisplay = 272,
+	.vsync_start = 272 + 2,
+	.vsync_end = 272 + 2 + 11,
+	.vtotal = 272 + 2 + 11 + 2,
+	.vrefresh = 60,
+	.flags = DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC,
+};
+
+static const struct panel_desc innolux_at043tn24 = {
+	.modes = &innolux_at043tn24_mode,
+	.num_modes = 1,
+	.bpc = 8,
+	.size = {
+		.width = 95,
+		.height = 54,
+	},
+	.bus_format = MEDIA_BUS_FMT_RGB888_1X24,
+};
+
+static const struct drm_display_mode innolux_g121i1_l01_mode = {
+	.clock = 71000,
+	.hdisplay = 1280,
+	.hsync_start = 1280 + 64,
+	.hsync_end = 1280 + 64 + 32,
+	.htotal = 1280 + 64 + 32 + 64,
+	.vdisplay = 800,
+	.vsync_start = 800 + 9,
+	.vsync_end = 800 + 9 + 6,
+	.vtotal = 800 + 9 + 6 + 9,
+	.vrefresh = 60,
+};
+
+static const struct panel_desc innolux_g121i1_l01 = {
+	.modes = &innolux_g121i1_l01_mode,
+	.num_modes = 1,
+	.bpc = 6,
+	.size = {
+		.width = 261,
+		.height = 163,
+	},
+};
+
+static const struct drm_display_mode innolux_n116bge_mode = {
+	.clock = 76420,
+	.hdisplay = 1366,
+	.hsync_start = 1366 + 136,
+	.hsync_end = 1366 + 136 + 30,
+	.htotal = 1366 + 136 + 30 + 60,
+	.vdisplay = 768,
+	.vsync_start = 768 + 8,
+	.vsync_end = 768 + 8 + 12,
+	.vtotal = 768 + 8 + 12 + 12,
+	.vrefresh = 60,
+	.flags = DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC,
+};
+
+static const struct panel_desc innolux_n116bge = {
+	.modes = &innolux_n116bge_mode,
+	.num_modes = 1,
+	.bpc = 6,
+	.size = {
+		.width = 256,
+		.height = 144,
+	},
+};
+
+static const struct drm_display_mode innolux_n125hce_mode = {
+	.clock = 138780,
+	.hdisplay = 1920,
+	.hsync_start = 1920 + 80,
+	.hsync_end = 1920 + 80 + 30,
+	.htotal = 1920 + 80 + 30 + 50,
+	.vdisplay = 1080,
+	.vsync_start = 1080 + 12,
+	.vsync_end = 1080 + 12 + 4,
+	.vtotal = 1080 + 12 + 4 + 16,
+	.vrefresh = 60,
+	.flags = DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC,
+};
+
+static const struct panel_desc innolux_n125hce = {
+	.modes = &innolux_n125hce_mode,
+	.num_modes = 1,
+	.bpc = 6,
+	.size = {
+		.width = 283,
+		.height = 168,
+	},
+	.delay = {
+		.unprepare = 600,
+		.enable = 100,
+	},
+	.bus_format = MEDIA_BUS_FMT_RGB666_1X18,
+};
+
+static const struct drm_display_mode innolux_n156bge_l21_mode = {
+	.clock = 69300,
+	.hdisplay = 1366,
+	.hsync_start = 1366 + 16,
+	.hsync_end = 1366 + 16 + 34,
+	.htotal = 1366 + 16 + 34 + 50,
+	.vdisplay = 768,
+	.vsync_start = 768 + 2,
+	.vsync_end = 768 + 2 + 6,
+	.vtotal = 768 + 2 + 6 + 12,
+	.vrefresh = 60,
+};
+
+static const struct panel_desc innolux_n156bge_l21 = {
+	.modes = &innolux_n156bge_l21_mode,
+	.num_modes = 1,
+	.bpc = 6,
+	.size = {
+		.width = 344,
+		.height = 193,
+	},
+};
+
+static const struct drm_display_mode innolux_zj070na_01p_mode = {
+	.clock = 51501,
+	.hdisplay = 1024,
+	.hsync_start = 1024 + 128,
+	.hsync_end = 1024 + 128 + 64,
+	.htotal = 1024 + 128 + 64 + 128,
+	.vdisplay = 600,
+	.vsync_start = 600 + 16,
+	.vsync_end = 600 + 16 + 4,
+	.vtotal = 600 + 16 + 4 + 16,
+	.vrefresh = 60,
+};
+
+static const struct panel_desc innolux_zj070na_01p = {
+	.modes = &innolux_zj070na_01p_mode,
+	.num_modes = 1,
+	.bpc = 6,
+	.size = {
+		.width = 1024,
+		.height = 600,
+	},
+};
+
+static const struct drm_display_mode lg_lb070wv8_mode = {
+	.clock = 33246,
+	.hdisplay = 800,
+	.hsync_start = 800 + 88,
+	.hsync_end = 800 + 88 + 80,
+	.htotal = 800 + 88 + 80 + 88,
+	.vdisplay = 480,
+	.vsync_start = 480 + 10,
+	.vsync_end = 480 + 10 + 25,
+	.vtotal = 480 + 10 + 25 + 10,
+	.vrefresh = 60,
+};
+
+static const struct panel_desc lg_lb070wv8 = {
+	.modes = &lg_lb070wv8_mode,
+	.num_modes = 1,
+	.bpc = 16,
+	.size = {
+		.width = 151,
+		.height = 91,
+	},
+	.bus_format = MEDIA_BUS_FMT_RGB888_1X7X4_SPWG,
+};
+
+static const struct drm_display_mode sharp_lcd_f402_mode = {
+	.clock = 205000,
+	.hdisplay = 1536,
+	.hsync_start = 1536 + 12,
+	.hsync_end = 1536 + 12 + 48,
+	.htotal = 1536 + 12 + 48 + 16,
+	.vdisplay = 2048,
+	.vsync_start = 2048 + 8,
+	.vsync_end = 2048 + 8 + 8,
+	.vtotal = 2048 + 8 + 8 + 4,
+	.vrefresh = 60,
+	.flags = DRM_MODE_FLAG_NVSYNC | DRM_MODE_FLAG_NHSYNC,
+};
+
+static const struct panel_desc sharp_lcd_f402 = {
+	.modes = &sharp_lcd_f402_mode,
+	.num_modes = 1,
+	.bpc = 8,
+	.size = {
+		.width = 95,
+		.height = 54,
+	},
+	.bus_format = MEDIA_BUS_FMT_RGB666_1X18,
+};
+
+static const struct drm_display_mode lg_lm238wr2_spa1_mode = {
+	.clock = 533250,
+	.hdisplay = 3840,
+	.hsync_start = 3840 + 48,
+	.hsync_end = 3840 + 48 + 32,
+	.htotal = 3840 + 48 + 32 + 80,
+	.vdisplay = 2160,
+	.vsync_start = 2160 + 3,
+	.vsync_end = 2160 + 3 + 5,
+	.vtotal = 2160 + 3 + 5 + 54,
+	.vrefresh = 60,
+	.flags = DRM_MODE_FLAG_NVSYNC | DRM_MODE_FLAG_NHSYNC,
+};
+
+static const struct panel_desc lg_lm238wr2_spa1 = {
+	.modes = &lg_lm238wr2_spa1_mode,
+	.num_modes = 1,
+	.bpc = 8,
+	.size = {
+		.width = 527,
+		.height = 297,
+	},
+	.delay = {
+		.prepare = 20,
+		.enable = 20,
+		.unprepare = 20,
+		.disable = 20,
+	},
+};
+
+static const struct drm_display_mode lg_lm270wr3_ssa1_mode = {
+	.clock = 533250,
+	.hdisplay = 3840,
+	.hsync_start = 3840 + 48,
+	.hsync_end = 3840 + 48 + 32,
+	.htotal = 3840 + 48 + 32 + 80,
+	.vdisplay = 2160,
+	.vsync_start = 2160 + 3,
+	.vsync_end = 2160 + 3 + 5,
+	.vtotal = 2160 + 3 + 5 + 54,
+	.vrefresh = 60,
+	.flags = DRM_MODE_FLAG_NVSYNC | DRM_MODE_FLAG_NHSYNC,
+};
+
+static const struct panel_desc lg_lm270wr3_ssa1 = {
+	.modes = &lg_lm270wr3_ssa1_mode,
+	.num_modes = 1,
+	.bpc = 10,
+	.size = {
+		.width = 598,
+		.height = 336,
+	},
+	.delay = {
+		.prepare = 20,
+		.enable = 20,
+		.unprepare = 20,
+		.disable = 20,
+	},
+};
+
+static const struct drm_display_mode lg_lp079qx1_sp0v_mode = {
+	.clock = 200000,
+	.hdisplay = 1536,
+	.hsync_start = 1536 + 12,
+	.hsync_end = 1536 + 12 + 16,
+	.htotal = 1536 + 12 + 16 + 48,
+	.vdisplay = 2048,
+	.vsync_start = 2048 + 8,
+	.vsync_end = 2048 + 8 + 4,
+	.vtotal = 2048 + 8 + 4 + 8,
+	.vrefresh = 60,
+	.flags = DRM_MODE_FLAG_NVSYNC | DRM_MODE_FLAG_NHSYNC,
+};
+
+static const struct panel_desc lg_lp079qx1_sp0v = {
+	.modes = &lg_lp079qx1_sp0v_mode,
+	.num_modes = 1,
+	.size = {
+		.width = 129,
+		.height = 171,
+	},
+	.bus_format = MEDIA_BUS_FMT_RGB666_1X18,
+};
+
+static const struct drm_display_mode lg_lp097qx1_spa1_mode = {
+	.clock = 205210,
+	.hdisplay = 2048,
+	.hsync_start = 2048 + 150,
+	.hsync_end = 2048 + 150 + 5,
+	.htotal = 2048 + 150 + 5 + 5,
+	.vdisplay = 1536,
+	.vsync_start = 1536 + 3,
+	.vsync_end = 1536 + 3 + 1,
+	.vtotal = 1536 + 3 + 1 + 9,
+	.vrefresh = 60,
+};
+
+static const struct panel_desc lg_lp097qx1_spa1 = {
+	.modes = &lg_lp097qx1_spa1_mode,
+	.num_modes = 1,
+	.size = {
+		.width = 320,
+		.height = 187,
+	},
+};
+
+static const struct drm_display_mode lg_lp129qe_mode = {
+	.clock = 285250,
+	.hdisplay = 2560,
+	.hsync_start = 2560 + 48,
+	.hsync_end = 2560 + 48 + 32,
+	.htotal = 2560 + 48 + 32 + 80,
+	.vdisplay = 1700,
+	.vsync_start = 1700 + 3,
+	.vsync_end = 1700 + 3 + 10,
+	.vtotal = 1700 + 3 + 10 + 36,
+	.vrefresh = 60,
+};
+
+static const struct panel_desc lg_lp129qe = {
+	.modes = &lg_lp129qe_mode,
+	.num_modes = 1,
+	.bpc = 8,
+	.size = {
+		.width = 272,
+		.height = 181,
+	},
+};
+
+static const struct drm_display_mode nec_nl4827hc19_05b_mode = {
+	.clock = 10870,
+	.hdisplay = 480,
+	.hsync_start = 480 + 2,
+	.hsync_end = 480 + 2 + 41,
+	.htotal = 480 + 2 + 41 + 2,
+	.vdisplay = 272,
+	.vsync_start = 272 + 2,
+	.vsync_end = 272 + 2 + 4,
+	.vtotal = 272 + 2 + 4 + 2,
+	.vrefresh = 74,
+};
+
+static const struct panel_desc nec_nl4827hc19_05b = {
+	.modes = &nec_nl4827hc19_05b_mode,
+	.num_modes = 1,
+	.bpc = 8,
+	.size = {
+		.width = 95,
+		.height = 54,
+	},
+	.bus_format = MEDIA_BUS_FMT_RGB888_1X24
+};
+
+static const struct display_timing okaya_rs800480t_7x0gp_timing = {
+	.pixelclock = { 30000000, 30000000, 40000000 },
+	.hactive = { 800, 800, 800 },
+	.hfront_porch = { 40, 40, 40 },
+	.hback_porch = { 40, 40, 40 },
+	.hsync_len = { 1, 48, 48 },
+	.vactive = { 480, 480, 480 },
+	.vfront_porch = { 13, 13, 13 },
+	.vback_porch = { 29, 29, 29 },
+	.vsync_len = { 3, 3, 3 },
+	.flags = DISPLAY_FLAGS_DE_HIGH,
+};
+
+static const struct panel_desc okaya_rs800480t_7x0gp = {
+	.timings = &okaya_rs800480t_7x0gp_timing,
+	.num_timings = 1,
+	.bpc = 6,
+	.size = {
+		.width = 154,
+		.height = 87,
+	},
+	.delay = {
+		.prepare = 41,
+		.enable = 50,
+		.unprepare = 41,
+		.disable = 50,
+	},
+	.bus_format = MEDIA_BUS_FMT_RGB666_1X18,
+};
+
+static const struct drm_display_mode ortustech_com43h4m85ulc_mode  = {
+	.clock = 25000,
+	.hdisplay = 480,
+	.hsync_start = 480 + 10,
+	.hsync_end = 480 + 10 + 10,
+	.htotal = 480 + 10 + 10 + 15,
+	.vdisplay = 800,
+	.vsync_start = 800 + 3,
+	.vsync_end = 800 + 3 + 3,
+	.vtotal = 800 + 3 + 3 + 3,
+	.vrefresh = 60,
+};
+
+static const struct panel_desc ortustech_com43h4m85ulc = {
+	.modes = &ortustech_com43h4m85ulc_mode,
+	.num_modes = 1,
+	.bpc = 8,
+	.size = {
+		.width = 56,
+		.height = 93,
+	},
+	.bus_format = MEDIA_BUS_FMT_RGB888_1X24,
+};
+
+static const struct drm_display_mode samsung_lsn122dl01_c01_mode = {
+	.clock = 271560,
+	.hdisplay = 2560,
+	.hsync_start = 2560 + 48,
+	.hsync_end = 2560 + 48 + 32,
+	.htotal = 2560 + 48 + 32 + 80,
+	.vdisplay = 1600,
+	.vsync_start = 1600 + 2,
+	.vsync_end = 1600 + 2 + 5,
+	.vtotal = 1600 + 2 + 5 + 57,
+	.vrefresh = 60,
+};
+
+static const struct panel_desc samsung_lsn122dl01_c01 = {
+	.modes = &samsung_lsn122dl01_c01_mode,
+	.num_modes = 1,
+	.size = {
+		.width = 2560,
+		.height = 1600,
+	},
+};
+
+static const struct drm_display_mode samsung_ltn101nt05_mode = {
+	.clock = 54030,
+	.hdisplay = 1024,
+	.hsync_start = 1024 + 24,
+	.hsync_end = 1024 + 24 + 136,
+	.htotal = 1024 + 24 + 136 + 160,
+	.vdisplay = 600,
+	.vsync_start = 600 + 3,
+	.vsync_end = 600 + 3 + 6,
+	.vtotal = 600 + 3 + 6 + 61,
+	.vrefresh = 60,
+};
+
+static const struct panel_desc samsung_ltn101nt05 = {
+	.modes = &samsung_ltn101nt05_mode,
+	.num_modes = 1,
+	.bpc = 6,
+	.size = {
+		.width = 1024,
+		.height = 600,
+	},
+};
+
+static const struct drm_display_mode samsung_ltn140at29_301_mode = {
+	.clock = 76300,
+	.hdisplay = 1366,
+	.hsync_start = 1366 + 64,
+	.hsync_end = 1366 + 64 + 48,
+	.htotal = 1366 + 64 + 48 + 128,
+	.vdisplay = 768,
+	.vsync_start = 768 + 2,
+	.vsync_end = 768 + 2 + 5,
+	.vtotal = 768 + 2 + 5 + 17,
+	.vrefresh = 60,
+};
+
+static const struct panel_desc samsung_ltn140at29_301 = {
+	.modes = &samsung_ltn140at29_301_mode,
+	.num_modes = 1,
+	.bpc = 6,
+	.size = {
+		.width = 320,
+		.height = 187,
+	},
+};
+
+static const struct drm_display_mode shelly_sca07010_bfn_lnn_mode = {
+	.clock = 33300,
+	.hdisplay = 800,
+	.hsync_start = 800 + 1,
+	.hsync_end = 800 + 1 + 64,
+	.htotal = 800 + 1 + 64 + 64,
+	.vdisplay = 480,
+	.vsync_start = 480 + 1,
+	.vsync_end = 480 + 1 + 23,
+	.vtotal = 480 + 1 + 23 + 22,
+	.vrefresh = 60,
+};
+
+static const struct panel_desc shelly_sca07010_bfn_lnn = {
+	.modes = &shelly_sca07010_bfn_lnn_mode,
+	.num_modes = 1,
+	.size = {
+		.width = 152,
+		.height = 91,
+	},
+	.bus_format = MEDIA_BUS_FMT_RGB666_1X18,
+};
+
+static const struct of_device_id platform_of_match[] = {
+	{
+		.compatible = "simple-panel",
+		.data = NULL,
+	}, {
+		.compatible = "ampire,am800480r3tmqwa1h",
+		.data = &ampire_am800480r3tmqwa1h,
+	}, {
+		.compatible = "auo,b101aw03",
+		.data = &auo_b101aw03,
+	}, {
+		.compatible = "auo,b101ean01",
+		.data = &auo_b101ean01,
+	}, {
+		.compatible = "auo,b101ew05",
+		.data = &auo_b101ew05,
+	}, {
+		.compatible = "auo,b101xtn01",
+		.data = &auo_b101xtn01,
+	}, {
+		.compatible = "auo,b116xw03",
+		.data = &auo_b116xw03,
+	}, {
+		.compatible = "auo,b125han03",
+		.data = &auo_b125han03,
+	}, {
+		.compatible = "auo,b133htn01",
+		.data = &auo_b133htn01,
+	}, {
+		.compatible = "auo,b133xtn01",
+		.data = &auo_b133xtn01,
+	}, {
+		.compatible = "avic,tm070ddh03",
+		.data = &avic_tm070ddh03,
+	}, {
+		.compatible = "boe,mv238qum-n20",
+		.data = &boe_mv238qum_n20,
+	}, {
+		.compatible = "boe,mv270qum-n10",
+		.data = &boe_mv270qum_n10,
+	}, {
+		.compatible = "boe,nv125fhm-n73",
+		.data = &boe_nv125fhm_n73,
+	}, {
+		.compatible = "chunghwa,claa070wp03xg",
+		.data = &chunghwa_claa070wp03xg,
+	}, {
+		.compatible = "chunghwa,claa101wa01a",
+		.data = &chunghwa_claa101wa01a
+	}, {
+		.compatible = "chunghwa,claa101wb01",
+		.data = &chunghwa_claa101wb01
+	}, {
+		.compatible = "edt,et057090dhu",
+		.data = &edt_et057090dhu,
+	}, {
+		.compatible = "edt,et070080dh6",
+		.data = &edt_etm0700g0dh6,
+	}, {
+		.compatible = "edt,etm0700g0dh6",
+		.data = &edt_etm0700g0dh6,
+	}, {
+		.compatible = "foxlink,fl500wvr00-a0t",
+		.data = &foxlink_fl500wvr00_a0t,
+	}, {
+		.compatible = "giantplus,gpg482739qs5",
+		.data = &giantplus_gpg482739qs5
+	}, {
+		.compatible = "hannstar,hsd070pww1",
+		.data = &hannstar_hsd070pww1,
+	}, {
+		.compatible = "hannstar,hsd100pxn1",
+		.data = &hannstar_hsd100pxn1,
+	}, {
+		.compatible = "hit,tx23d38vm0caa",
+		.data = &hitachi_tx23d38vm0caa
+	}, {
+		.compatible = "innolux,at043tn24",
+		.data = &innolux_at043tn24,
+	}, {
+		.compatible ="innolux,g121i1-l01",
+		.data = &innolux_g121i1_l01
+	}, {
+		.compatible = "innolux,n116bge",
+		.data = &innolux_n116bge,
+	}, {
+		.compatible = "innolux,n125hce",
+		.data = &innolux_n125hce,
+	}, {
+		.compatible = "innolux,n156bge-l21",
+		.data = &innolux_n156bge_l21,
+	}, {
+		.compatible = "innolux,zj070na-01p",
+		.data = &innolux_zj070na_01p,
+	}, {
+		.compatible = "lg,lb070wv8",
+		.data = &lg_lb070wv8,
+	}, {
+		.compatible = "lg,lm238wr2-spa1",
+		.data = &lg_lm238wr2_spa1,
+	}, {
+		.compatible = "lg,lm270wr3-ssa1",
+		.data = &lg_lm270wr3_ssa1,
+	}, {
+		.compatible = "lg,lp079qx1-sp0v",
+		.data = &lg_lp079qx1_sp0v,
+	}, {
+		.compatible = "lg,lp097qx1-spa1",
+		.data = &lg_lp097qx1_spa1,
+	}, {
+		.compatible = "lg,lp129qe",
+		.data = &lg_lp129qe,
+	}, {
+		.compatible = "nec,nl4827hc19-05b",
+		.data = &nec_nl4827hc19_05b,
+	}, {
+		.compatible = "okaya,rs800480t-7x0gp",
+		.data = &okaya_rs800480t_7x0gp,
+	}, {
+		.compatible = "ortustech,com43h4m85ulc",
+		.data = &ortustech_com43h4m85ulc,
+	}, {
+		.compatible = "samsung,lsn122dl01-c01",
+		.data = &samsung_lsn122dl01_c01,
+	}, {
+		.compatible = "samsung,ltn101nt05",
+		.data = &samsung_ltn101nt05,
+	}, {
+		.compatible = "samsung,ltn140at29-301",
+		.data = &samsung_ltn140at29_301,
+	}, {
+		.compatible = "sharp,lcd-f402",
+		.data = &sharp_lcd_f402,
+	}, {
+		.compatible = "shelly,sca07010-bfn-lnn",
+		.data = &shelly_sca07010_bfn_lnn,
+	}, {
+		/* sentinel */
+	}
+};
+MODULE_DEVICE_TABLE(of, platform_of_match);
+
+static int panel_simple_platform_probe(struct platform_device *pdev)
+{
+	const struct of_device_id *id;
+
+	id = of_match_node(platform_of_match, pdev->dev.of_node);
+	if (!id)
+		return -ENODEV;
+
+	return panel_simple_probe(&pdev->dev, id->data);
+}
+
+static int panel_simple_platform_remove(struct platform_device *pdev)
+{
+	return panel_simple_remove(&pdev->dev);
+}
+
+static void panel_simple_platform_shutdown(struct platform_device *pdev)
+{
+	panel_simple_shutdown(&pdev->dev);
+}
+
+static struct platform_driver panel_simple_platform_driver = {
+	.driver = {
+		.name = "panel-simple",
+		.of_match_table = platform_of_match,
+	},
+	.probe = panel_simple_platform_probe,
+	.remove = panel_simple_platform_remove,
+	.shutdown = panel_simple_platform_shutdown,
+};
+
+struct panel_desc_dsi {
+	struct panel_desc desc;
+
+	unsigned long flags;
+	enum mipi_dsi_pixel_format format;
+	unsigned int lanes;
+};
+
+static const struct drm_display_mode auo_b080uan01_mode = {
+	.clock = 154500,
+	.hdisplay = 1200,
+	.hsync_start = 1200 + 62,
+	.hsync_end = 1200 + 62 + 4,
+	.htotal = 1200 + 62 + 4 + 62,
+	.vdisplay = 1920,
+	.vsync_start = 1920 + 9,
+	.vsync_end = 1920 + 9 + 2,
+	.vtotal = 1920 + 9 + 2 + 8,
+	.vrefresh = 60,
+};
+
+static const struct panel_desc_dsi auo_b080uan01 = {
+	.desc = {
+		.modes = &auo_b080uan01_mode,
+		.num_modes = 1,
+		.bpc = 8,
+		.size = {
+			.width = 108,
+			.height = 272,
+		},
+	},
+	.flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_CLOCK_NON_CONTINUOUS,
+	.format = MIPI_DSI_FMT_RGB888,
+	.lanes = 4,
+};
+
+static const struct drm_display_mode boe_tv080wum_nl0_mode = {
+	.clock = 160000,
+	.hdisplay = 1200,
+	.hsync_start = 1200 + 120,
+	.hsync_end = 1200 + 120 + 20,
+	.htotal = 1200 + 120 + 20 + 21,
+	.vdisplay = 1920,
+	.vsync_start = 1920 + 21,
+	.vsync_end = 1920 + 21 + 3,
+	.vtotal = 1920 + 21 + 3 + 18,
+	.vrefresh = 60,
+	.flags = DRM_MODE_FLAG_NVSYNC | DRM_MODE_FLAG_NHSYNC,
+};
+
+static const struct panel_desc_dsi boe_tv080wum_nl0 = {
+	.desc = {
+		.modes = &boe_tv080wum_nl0_mode,
+		.num_modes = 1,
+		.size = {
+			.width = 107,
+			.height = 172,
+		},
+	},
+	.flags = MIPI_DSI_MODE_VIDEO |
+		 MIPI_DSI_MODE_VIDEO_BURST |
+		 MIPI_DSI_MODE_VIDEO_SYNC_PULSE,
+	.format = MIPI_DSI_FMT_RGB888,
+	.lanes = 4,
+};
+
+static const struct drm_display_mode lg_ld070wx3_sl01_mode = {
+	.clock = 71000,
+	.hdisplay = 800,
+	.hsync_start = 800 + 32,
+	.hsync_end = 800 + 32 + 1,
+	.htotal = 800 + 32 + 1 + 57,
+	.vdisplay = 1280,
+	.vsync_start = 1280 + 28,
+	.vsync_end = 1280 + 28 + 1,
+	.vtotal = 1280 + 28 + 1 + 14,
+	.vrefresh = 60,
+};
+
+static const struct panel_desc_dsi lg_ld070wx3_sl01 = {
+	.desc = {
+		.modes = &lg_ld070wx3_sl01_mode,
+		.num_modes = 1,
+		.bpc = 8,
+		.size = {
+			.width = 94,
+			.height = 151,
+		},
+	},
+	.flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_CLOCK_NON_CONTINUOUS,
+	.format = MIPI_DSI_FMT_RGB888,
+	.lanes = 4,
+};
+
+static const struct drm_display_mode lg_lh500wx1_sd03_mode = {
+	.clock = 67000,
+	.hdisplay = 720,
+	.hsync_start = 720 + 12,
+	.hsync_end = 720 + 12 + 4,
+	.htotal = 720 + 12 + 4 + 112,
+	.vdisplay = 1280,
+	.vsync_start = 1280 + 8,
+	.vsync_end = 1280 + 8 + 4,
+	.vtotal = 1280 + 8 + 4 + 12,
+	.vrefresh = 60,
+};
+
+static const struct panel_desc_dsi lg_lh500wx1_sd03 = {
+	.desc = {
+		.modes = &lg_lh500wx1_sd03_mode,
+		.num_modes = 1,
+		.bpc = 8,
+		.size = {
+			.width = 62,
+			.height = 110,
+		},
+	},
+	.flags = MIPI_DSI_MODE_VIDEO,
+	.format = MIPI_DSI_FMT_RGB888,
+	.lanes = 4,
+};
+
+static const struct drm_display_mode panasonic_vvx10f004b00_mode = {
+	.clock = 157200,
+	.hdisplay = 1920,
+	.hsync_start = 1920 + 154,
+	.hsync_end = 1920 + 154 + 16,
+	.htotal = 1920 + 154 + 16 + 32,
+	.vdisplay = 1200,
+	.vsync_start = 1200 + 17,
+	.vsync_end = 1200 + 17 + 2,
+	.vtotal = 1200 + 17 + 2 + 16,
+	.vrefresh = 60,
+};
+
+static const struct panel_desc_dsi panasonic_vvx10f004b00 = {
+	.desc = {
+		.modes = &panasonic_vvx10f004b00_mode,
+		.num_modes = 1,
+		.bpc = 8,
+		.size = {
+			.width = 217,
+			.height = 136,
+		},
+	},
+	.flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_SYNC_PULSE |
+		 MIPI_DSI_CLOCK_NON_CONTINUOUS,
+	.format = MIPI_DSI_FMT_RGB888,
+	.lanes = 4,
+};
+
+
+static const struct of_device_id dsi_of_match[] = {
+	{
+		.compatible = "simple-panel-dsi",
+		.data = NULL
+	}, {
+		.compatible = "auo,b080uan01",
+		.data = &auo_b080uan01
+	}, {
+		.compatible = "boe,tv080wum-nl0",
+		.data = &boe_tv080wum_nl0
+	}, {
+		.compatible = "lg,ld070wx3-sl01",
+		.data = &lg_ld070wx3_sl01
+	}, {
+		.compatible = "lg,lh500wx1-sd03",
+		.data = &lg_lh500wx1_sd03
+	}, {
+		.compatible = "panasonic,vvx10f004b00",
+		.data = &panasonic_vvx10f004b00
+	}, {
+		/* sentinel */
+	}
+};
+MODULE_DEVICE_TABLE(of, dsi_of_match);
+
+static int panel_simple_dsi_probe(struct mipi_dsi_device *dsi)
+{
+	struct panel_simple *panel;
+	const struct panel_desc_dsi *desc;
+	const struct of_device_id *id;
+	const struct panel_desc *pdesc;
+	int err;
+	u32 val;
+
+	id = of_match_node(dsi_of_match, dsi->dev.of_node);
+	if (!id)
+		return -ENODEV;
+
+	desc = id->data;
+
+	if (desc) {
+		dsi->mode_flags = desc->flags;
+		dsi->format = desc->format;
+		dsi->lanes = desc->lanes;
+		pdesc = &desc->desc;
+	} else {
+		pdesc = NULL;
+	}
+
+	err = panel_simple_probe(&dsi->dev, pdesc);
+	if (err < 0)
+		return err;
+
+	panel = dev_get_drvdata(&dsi->dev);
+	panel->dsi = dsi;
+
+	if (!of_property_read_u32(dsi->dev.of_node, "dsi,flags", &val))
+		dsi->mode_flags = val;
+
+	if (!of_property_read_u32(dsi->dev.of_node, "dsi,format", &val))
+		dsi->format = val;
+
+	if (!of_property_read_u32(dsi->dev.of_node, "dsi,lanes", &val))
+		dsi->lanes = val;
+
+	return mipi_dsi_attach(dsi);
+}
+
+static int panel_simple_dsi_remove(struct mipi_dsi_device *dsi)
+{
+	int err;
+
+	err = mipi_dsi_detach(dsi);
+	if (err < 0)
+		dev_err(&dsi->dev, "failed to detach from DSI host: %d\n", err);
+
+	return panel_simple_remove(&dsi->dev);
+}
+
+static void panel_simple_dsi_shutdown(struct mipi_dsi_device *dsi)
+{
+	panel_simple_shutdown(&dsi->dev);
+}
+
+static struct mipi_dsi_driver panel_simple_dsi_driver = {
+	.driver = {
+		.name = "panel-simple-dsi",
+		.of_match_table = dsi_of_match,
+	},
+	.probe = panel_simple_dsi_probe,
+	.remove = panel_simple_dsi_remove,
+	.shutdown = panel_simple_dsi_shutdown,
+};
+
+static int __init panel_simple_init(void)
+{
+	int err;
+
+	err = platform_driver_register(&panel_simple_platform_driver);
+	if (err < 0)
+		return err;
+
+	if (IS_ENABLED(CONFIG_DRM_MIPI_DSI)) {
+		err = mipi_dsi_driver_register(&panel_simple_dsi_driver);
+		if (err < 0)
+			return err;
+	}
+
+	return 0;
+}
+module_init(panel_simple_init);
+
+static void __exit panel_simple_exit(void)
+{
+	if (IS_ENABLED(CONFIG_DRM_MIPI_DSI))
+		mipi_dsi_driver_unregister(&panel_simple_dsi_driver);
+
+	platform_driver_unregister(&panel_simple_platform_driver);
+}
+module_exit(panel_simple_exit);
+
+MODULE_AUTHOR("Thierry Reding <treding@nvidia.com>");
+MODULE_DESCRIPTION("DRM Driver for Simple Panels");
+MODULE_LICENSE("GPL and additional rights");
diff --git a/drivers/gpu/drm/panel/panel-simple.c b/drivers/gpu/drm/panel/panel-simple.c
old mode 100644
new mode 100755
index 700ffd65c7c1..7d9da7e7078c
--- a/drivers/gpu/drm/panel/panel-simple.c
+++ b/drivers/gpu/drm/panel/panel-simple.c
@@ -40,6 +40,12 @@
 #include <linux/of_graph.h>
 #include <video/videomode.h>
 
+#include <linux/string.h>
+#include <linux/vmalloc.h>
+#include <asm/uaccess.h>
+#include <linux/proc_fs.h>
+#include <asm/io.h>
+
 struct cmd_ctrl_hdr {
 	u8 dtype;	/* data type */
 	u8 wait;	/* ms */
@@ -120,6 +126,10 @@ struct panel_simple {
 	struct gpio_desc *spi_scl_gpio;
 	struct gpio_desc *spi_cs_gpio;
 
+	struct gpio_desc *spi_sdo_gpio;	//zwh
+	struct gpio_desc *spi_sdc_gpio;
+	struct gpio_desc *spi_shut_gpio;
+
 	struct panel_cmds *on_cmds;
 	struct panel_cmds *off_cmds;
 	struct device_node *np_crtc;
@@ -128,7 +138,8 @@ struct panel_simple {
 enum rockchip_cmd_type {
 	CMD_TYPE_DEFAULT,
 	CMD_TYPE_SPI,
-	CMD_TYPE_MCU
+	CMD_TYPE_MCU,
+	CMD_TYPE_MYSPI
 };
 
 enum MCU_IOCTL {
@@ -137,6 +148,9 @@ enum MCU_IOCTL {
 	MCU_SETBYPASS,
 };
 
+struct panel_simple *mypanel;
+
+
 static void panel_simple_sleep(unsigned int msec)
 {
 	if (msec > 20)
@@ -144,7 +158,7 @@ static void panel_simple_sleep(unsigned int msec)
 	else
 		usleep_range(msec * 1000, (msec + 1) * 1000);
 }
-
+#include "panel_ssd2828.c"
 static inline int get_panel_cmd_type(const char *s)
 {
 	if (!s)
@@ -152,9 +166,12 @@ static inline int get_panel_cmd_type(const char *s)
 
 	if (strncmp(s, "spi", 3) == 0)
 		return CMD_TYPE_SPI;
+	if (strncmp(s, "myspi", 5) == 0)			//zwh
+		return CMD_TYPE_MYSPI;
 	else if (strncmp(s, "mcu", 3) == 0)
 		return CMD_TYPE_MCU;
-
+	else if (strncmp(s, "myspi", 5) == 0)
+		return CMD_TYPE_MYSPI;
 	return CMD_TYPE_DEFAULT;
 }
 
@@ -420,7 +437,7 @@ static int panel_simple_get_fixed_modes(struct panel_simple *panel)
 	struct drm_device *drm = panel->base.drm;
 	struct drm_display_mode *mode;
 	unsigned int i, num = 0;
-
+	printk("============zwh %s %s %d num_timings=%d\n", __FILE__,__func__, __LINE__, panel->desc->num_timings);
 	if (!panel->desc)
 		return 0;
 
@@ -476,7 +493,7 @@ static int panel_simple_of_get_native_mode(struct panel_simple *panel)
 	struct drm_display_mode *mode;
 	struct device_node *timings_np;
 	int ret;
-
+	printk("============zwh %s %s %d\n", __FILE__,__func__, __LINE__);
 	timings_np = of_get_child_by_name(panel->dev->of_node,
 					  "display-timings");
 	if (!timings_np) {
@@ -508,7 +525,7 @@ static int panel_simple_regulator_enable(struct drm_panel *panel)
 {
 	struct panel_simple *p = to_panel_simple(panel);
 	int err = 0;
-
+	printk("============zwh %s %s %d\n", __FILE__,__func__, __LINE__);
 	if (p->power_invert) {
 		if (regulator_is_enabled(p->supply) > 0)
 			regulator_disable(p->supply);
@@ -528,7 +545,7 @@ static int panel_simple_regulator_disable(struct drm_panel *panel)
 {
 	struct panel_simple *p = to_panel_simple(panel);
 	int err = 0;
-
+	printk("============zwh %s %s %d\n", __FILE__,__func__, __LINE__);
 	if (p->power_invert) {
 		if (!regulator_is_enabled(p->supply)) {
 			err = regulator_enable(p->supply);
@@ -548,7 +565,7 @@ static int panel_simple_regulator_disable(struct drm_panel *panel)
 static int panel_simple_loader_protect(struct drm_panel *panel, bool on)
 {
 	int err;
-
+	printk("============zwh %s %s %d\n", __FILE__,__func__, __LINE__);
 	if (on) {
 		err = panel_simple_regulator_enable(panel);
 		if (err < 0) {
@@ -567,7 +584,7 @@ static int panel_simple_disable(struct drm_panel *panel)
 {
 	struct panel_simple *p = to_panel_simple(panel);
 	int err = 0;
-
+	printk("============zwh %s %s %d\n", __FILE__,__func__, __LINE__);
 	if (!p->enabled)
 		return 0;
 
@@ -593,7 +610,7 @@ static int panel_simple_unprepare(struct drm_panel *panel)
 {
 	struct panel_simple *p = to_panel_simple(panel);
 	int err = 0;
-
+	printk("============zwh %s %s %d\n", __FILE__,__func__, __LINE__);
 	if (!p->prepared)
 		return 0;
 
@@ -602,6 +619,8 @@ static int panel_simple_unprepare(struct drm_panel *panel)
 			err = panel_simple_dsi_send_cmds(p, p->off_cmds);
 		else if (p->cmd_type == CMD_TYPE_SPI)
 			err = panel_simple_spi_send_cmds(p, p->off_cmds);
+		else if (p->cmd_type == CMD_TYPE_MYSPI)
+			err = panel_simple_myspi_send_cmds(p, p->off_cmds);		//zwh
 		if (err)
 			dev_err(p->dev, "failed to send off cmds\n");
 	}
@@ -618,15 +637,49 @@ static int panel_simple_unprepare(struct drm_panel *panel)
 		panel_simple_sleep(p->desc->delay.unprepare);
 
 	p->prepared = false;
-
+	printk("============zwh %s %s %d\n", __FILE__,__func__, __LINE__);
 	return 0;
 }
 
+int debug_panel_simple_prepare(struct panel_simple *p)
+{
+	//struct panel_simple *p = to_panel_simple(panel);
+	int err;
+	printk("============zwh %s %s %d\n", __FILE__,__func__, __LINE__);
+	if (p->prepared)
+		return 0;
+
+	if (p->enable_gpio)
+		gpiod_direction_output(p->enable_gpio, 1);
+
+	if (p->desc && p->desc->delay.prepare)
+		panel_simple_sleep(p->desc->delay.prepare);
+
+	if (p->reset_gpio)
+		gpiod_direction_output(p->reset_gpio, 1);
+
+	if (p->desc && p->desc->delay.reset)
+		panel_simple_sleep(p->desc->delay.reset);
+
+	if (p->reset_gpio)
+		gpiod_direction_output(p->reset_gpio, 0);
+
+	if (p->desc && p->desc->delay.init)
+		panel_simple_sleep(p->desc->delay.init);
+
+
+	err = panel_simple_myspi_send_cmds(p, p->on_cmds);	//zwh		
+	if (err)
+		dev_err(p->dev, "failed to send on cmds\n");
+
+	printk("============zwh %s %s %d\n", __FILE__,__func__, __LINE__);
+	return 0;
+}
 static int panel_simple_prepare(struct drm_panel *panel)
 {
 	struct panel_simple *p = to_panel_simple(panel);
 	int err;
-
+	printk("============zwh %s %s %d\n", __FILE__,__func__, __LINE__);
 	if (p->prepared)
 		return 0;
 
@@ -659,10 +712,12 @@ static int panel_simple_prepare(struct drm_panel *panel)
 			err = panel_simple_dsi_send_cmds(p, p->on_cmds);
 		else if (p->cmd_type == CMD_TYPE_SPI)
 			err = panel_simple_spi_send_cmds(p, p->on_cmds);
+		else if (p->cmd_type == CMD_TYPE_MYSPI)
+			err = panel_simple_myspi_send_cmds(p, p->on_cmds);	//zwh		
 		if (err)
 			dev_err(p->dev, "failed to send on cmds\n");
 	}
-
+	printk("============zwh %s %s %d\n", __FILE__,__func__, __LINE__);
 	p->prepared = true;
 
 	return 0;
@@ -672,7 +727,7 @@ static int panel_simple_enable(struct drm_panel *panel)
 {
 	struct panel_simple *p = to_panel_simple(panel);
 	int err = 0;
-
+	printk("============zwh %s %s %d\n", __FILE__,__func__, __LINE__);
 	if (p->enabled)
 		return 0;
 
@@ -690,7 +745,7 @@ static int panel_simple_enable(struct drm_panel *panel)
 	}
 
 	p->enabled = true;
-
+	printk("============zwh %s %s %d\n", __FILE__,__func__, __LINE__);
 	return 0;
 }
 
@@ -698,7 +753,7 @@ static int panel_simple_get_modes(struct drm_panel *panel)
 {
 	struct panel_simple *p = to_panel_simple(panel);
 	int num = 0;
-
+	printk("============zwh %s %s %d\n", __FILE__,__func__, __LINE__);
 	/* add device node plane modes */
 	num += panel_simple_of_get_native_mode(p);
 
@@ -724,7 +779,7 @@ static int panel_simple_get_timings(struct drm_panel *panel,
 {
 	struct panel_simple *p = to_panel_simple(panel);
 	unsigned int i;
-
+	printk("============zwh %s %s %d\n", __FILE__,__func__, __LINE__);	//test
 	if (!p->desc)
 		return 0;
 
@@ -756,7 +811,7 @@ static int panel_simple_probe(struct device *dev, const struct panel_desc *desc)
 	const char *cmd_type;
 	u32 val;
 	int err;
-
+	printk("============zwh %s %s %d\n", __FILE__,__func__, __LINE__);
 	panel = devm_kzalloc(dev, sizeof(*panel), GFP_KERNEL);
 	if (!panel)
 		return -ENOMEM;
@@ -791,7 +846,7 @@ static int panel_simple_probe(struct device *dev, const struct panel_desc *desc)
 	panel->prepared = false;
 	panel->desc = of_desc;
 	panel->dev = dev;
-
+	printk("============zwh %s %s %d\n", __FILE__,__func__, __LINE__);
 	err = panel_simple_get_cmds(panel);
 	if (err) {
 		dev_err(dev, "failed to get init cmd: %d\n", err);
@@ -799,7 +854,10 @@ static int panel_simple_probe(struct device *dev, const struct panel_desc *desc)
 	}
 	panel->supply = devm_regulator_get(dev, "power");
 	if (IS_ERR(panel->supply))
+	{
+		printk("============zwh %s %s %d\n", __FILE__,__func__, __LINE__);
 		return PTR_ERR(panel->supply);
+	}
 
 	panel->enable_gpio = devm_gpiod_get_optional(dev, "enable", 0);
 	if (IS_ERR(panel->enable_gpio)) {
@@ -821,7 +879,8 @@ static int panel_simple_probe(struct device *dev, const struct panel_desc *desc)
 	else
 		panel->cmd_type = get_panel_cmd_type(cmd_type);
 
-	if (panel->cmd_type == CMD_TYPE_SPI) {
+	if (panel->cmd_type == CMD_TYPE_SPI || panel->cmd_type == CMD_TYPE_MYSPI) {//zwh
+
 		panel->spi_sdi_gpio =
 				devm_gpiod_get_optional(dev, "spi-sdi", 0);
 		if (IS_ERR(panel->spi_sdi_gpio)) {
@@ -844,9 +903,36 @@ static int panel_simple_probe(struct device *dev, const struct panel_desc *desc)
 			dev_err(dev, "failed to request spi_cs: %d\n", err);
 			return err;
 		}
+
+		panel->spi_sdo_gpio = devm_gpiod_get_optional(dev, "spi-sdo", 0);
+		if (IS_ERR(panel->spi_sdo_gpio)) {
+			err = PTR_ERR(panel->spi_sdo_gpio);
+			dev_err(dev, "failed to request spi_sdo_gpio: %d\n", err);
+			return err;
+		}
+		panel->spi_sdc_gpio = devm_gpiod_get_optional(dev, "spi-sdc", 0);
+		if (IS_ERR(panel->spi_sdc_gpio)) {
+			err = PTR_ERR(panel->spi_sdc_gpio);
+			dev_err(dev, "failed to request spi_sdc_gpio: %d\n", err);
+			return err;
+		}
+		panel->spi_shut_gpio = devm_gpiod_get_optional(dev, "spi-shut", 0);
+		if (IS_ERR(panel->spi_shut_gpio)) {
+			err = PTR_ERR(panel->spi_shut_gpio);
+			dev_err(dev, "failed to request spi_shut_gpio: %d\n", err);
+			return err;
+		}
+
+		gpiod_direction_output(panel->spi_sdc_gpio, 1);
+		gpiod_direction_output(panel->spi_shut_gpio, 1);
+		printk("====================zwh %s %d\n", __FUNCTION__, __LINE__);
+		gpiod_direction_input(panel->spi_sdo_gpio);				//zwh
+		printk("====================zwh %s %d\n", __FUNCTION__, __LINE__);
 		gpiod_direction_output(panel->spi_cs_gpio, 1);
 		gpiod_direction_output(panel->spi_sdi_gpio, 1);
 		gpiod_direction_output(panel->spi_scl_gpio, 1);
+
+		printk("====================zwh %s %d\n", __FUNCTION__, __LINE__);
 	} else if (panel->cmd_type == CMD_TYPE_MCU) {
 		struct device_node *port, *endpoint;
 		struct device_node *np;
@@ -898,7 +984,9 @@ static int panel_simple_probe(struct device *dev, const struct panel_desc *desc)
 		goto free_ddc;
 
 	dev_set_drvdata(dev, panel);
-
+	printk("============zwh %s %s %d  ok\n", __FILE__,__func__, __LINE__);
+	mypanel = panel;
+	ssd2828_debug_init();
 	return 0;
 
 free_ddc:
@@ -2154,11 +2242,13 @@ MODULE_DEVICE_TABLE(of, platform_of_match);
 static int panel_simple_platform_probe(struct platform_device *pdev)
 {
 	const struct of_device_id *id;
-
+	printk("==========================zwh %s %s %d pdev->dev.of_node->name=%s\n", __FILE__,__FUNCTION__,__LINE__, pdev->dev.of_node->name);
 	id = of_match_node(platform_of_match, pdev->dev.of_node);
 	if (!id)
+	{
+		printk("==========================zwh %s %s %d match %s error\n", __FILE__,__FUNCTION__,__LINE__, pdev->dev.of_node->name);
 		return -ENODEV;
-
+	}
 	return panel_simple_probe(&pdev->dev, id->data);
 }
 
@@ -2431,17 +2521,22 @@ static struct mipi_dsi_driver panel_simple_dsi_driver = {
 static int __init panel_simple_init(void)
 {
 	int err;
-
+	printk("============zwh %s %s %d\n", __FILE__,__func__, __LINE__);
 	err = platform_driver_register(&panel_simple_platform_driver);
 	if (err < 0)
+	{
+		printk("============zwh %s %s %d\n", __FILE__,__func__, __LINE__);
 		return err;
-
+	}
 	if (IS_ENABLED(CONFIG_DRM_MIPI_DSI)) {
 		err = mipi_dsi_driver_register(&panel_simple_dsi_driver);
 		if (err < 0)
+		{
+			printk("============zwh %s %s %d\n", __FILE__,__func__, __LINE__);
 			return err;
+		}
 	}
-
+	printk("============zwh %s %s %d\n", __FILE__,__func__, __LINE__);
 	return 0;
 }
 module_init(panel_simple_init);
diff --git a/drivers/gpu/drm/panel/panel_ssd2828.c b/drivers/gpu/drm/panel/panel_ssd2828.c
new file mode 100755
index 000000000000..5b73ef333de9
--- /dev/null
+++ b/drivers/gpu/drm/panel/panel_ssd2828.c
@@ -0,0 +1,632 @@
+/*
+SPI2_MISO_LCD  GPIO1_C6 W9
+SPI2_MOSI_LCD  GPIO1_C7 T9
+SPI2_CLK_LCD   GPIO1_D0 V10
+SPI2_CS_LCD    GPIO1_D1 T10
+
+LCD_SHUT       GPIO2_B1 V14
+LCD_SDC	       GPIO2_B2 V15
+
+LCD_BL	       GPIO2_B4 B4	
+
+*/
+
+#define LCD_CS_CLR 		gpiod_direction_output(mypanel->spi_cs_gpio, 0)		// SC
+#define LCD_CS_SET 		gpiod_direction_output(mypanel->spi_cs_gpio, 1)		
+#define LCD_SCK_CLR 	gpiod_direction_output(mypanel->spi_scl_gpio, 0)		// SCK
+#define LCD_SCK_SET 	gpiod_direction_output(mypanel->spi_scl_gpio, 1)
+#define LCD_MOSI_CLR 	gpiod_direction_output(mypanel->spi_sdi_gpio, 0)		// MOSI
+#define LCD_MOSI_SET 	gpiod_direction_output(mypanel->spi_sdi_gpio, 1)
+//#define LCD_RESET_CLR 	gpiod_direction_output(0, 3, 0)		// RESET  
+//#define LCD_RESET_SET 	gpiod_direction_output(0, 3, 1)
+																// MISO
+
+#define GPIO_PWRDET_EINT_PIN3	35      // PB03
+#define GPIO_PWRDET_LED2		139		// PE11
+
+#define GPIO_LCD_POWER          34      // PB02 BL_EN
+
+
+
+static void SPI_3W_SET_Data(unsigned int Sdata)
+{
+	unsigned int i;
+	LCD_CS_CLR;
+	
+	udelay(5);
+	LCD_MOSI_SET;	//高，
+    udelay(1);
+	LCD_SCK_CLR; //上升沿发送数据
+    udelay(2);
+	LCD_SCK_SET;
+	udelay(2);
+	
+	for(i=8; i>0; i--)
+	{
+		if(Sdata&0x80)//判断高位是否为1
+		{
+			LCD_MOSI_SET;
+		}
+		else
+		{
+			LCD_MOSI_CLR;
+		}
+
+		LCD_SCK_CLR; //上升沿发送数据
+		udelay(2);
+		LCD_SCK_SET;
+		udelay(1);
+		Sdata <<= 1;
+	} 
+	LCD_SCK_CLR;
+	udelay(1); 
+	
+	LCD_CS_SET;
+	udelay(5);
+}
+
+static unsigned int SSD2828SPIRead(void)
+{
+	unsigned int nData;
+	int x = 0;
+
+	unsigned int Value = 0;
+	
+	gpiod_direction_input(mypanel->spi_sdi_gpio);
+	LCD_CS_CLR;
+	
+	LCD_SCK_CLR;
+ 	udelay(5);
+	for( x = 0 ; x < 8 ; x++)
+	{
+		LCD_SCK_CLR; 
+	    udelay(1);
+	    LCD_SCK_SET;
+	    udelay(1);
+		Value <<=1;
+		
+		nData =gpiod_get_value(mypanel->spi_sdo_gpio);
+		if(nData==1)		// no user
+		{
+		   Value |=0x01;
+		}
+	}
+
+	LCD_CS_SET;
+ 	udelay(5);
+	return  Value;
+}
+
+static void SPI_3W_SET_Cmd(unsigned int Sdata)//设备ID发送函数
+{
+	unsigned int i;
+	LCD_CS_CLR;
+	
+	udelay(5);
+	LCD_MOSI_CLR;				// 低
+	udelay(1);
+	LCD_SCK_CLR; 
+	udelay(2);
+	LCD_SCK_SET;
+	udelay(2);
+	
+	for(i=8; i>0; i--)
+	{
+		if(Sdata&0x80)
+		{
+			LCD_MOSI_SET;
+		}
+		else 
+		{
+		  	LCD_MOSI_CLR;
+		}
+
+		LCD_SCK_CLR;
+		udelay(2);
+	    LCD_SCK_SET;
+		udelay(1);
+		Sdata <<= 1;
+	 } 
+	 LCD_SCK_CLR;
+	 udelay(1); 
+	 
+	 LCD_CS_SET;
+	 udelay(5);
+}
+
+static int ssd2828_esd_check(void)
+{
+    unsigned int DeviceID, DeviceID2;
+	SPI_3W_SET_Cmd(0xB0);SPI_3W_SET_Cmd(0xFA);
+	DeviceID = SSD2828SPIRead();
+	DeviceID2 = SSD2828SPIRead();
+	printk("ssd2828 read val1=%x val2=%x\n", DeviceID, DeviceID2);
+    if((DeviceID==0x28)&& (DeviceID==0x28))
+	{
+
+		return 0;
+	}
+	else
+	{
+		return -1;
+	}
+}
+
+static void SPI_WriteData(unsigned char value)
+{
+	LCD_CS_CLR;
+	SPI_3W_SET_Data(value);
+	LCD_CS_SET;	
+}
+
+static void SPI_2825_WrCmd(unsigned char value)
+{
+	LCD_CS_CLR;
+	SPI_3W_SET_Cmd(value);
+	LCD_CS_SET;	
+}
+
+static void GP_COMMAD_PA(int a)		// 写命令
+{
+ 	SPI_2825_WrCmd(0xBC);
+	SPI_WriteData(a);
+	SPI_WriteData(a>>8);
+	SPI_2825_WrCmd(0xBF);
+}
+
+/*
+static void ssd2828_set_cmd(u8 cmd)
+{
+	GP_COMMAD_PA(1);
+	SPI_WriteData(cmd);
+}
+*/
+
+static void ssd2828_set_cmdq(u8 cmd, u8 count, u8 *para)
+{
+	u8 i;
+	GP_COMMAD_PA(count+1);
+	SPI_WriteData(cmd);
+	//printk("%x  ", cmd);
+	for(i=0; i<count; i++)
+	{
+		SPI_WriteData(para[i]); 
+		//printk("%02x  ", para[i]);
+	}
+	//printk("\n");
+}
+
+struct LCM_setting_table {
+	u8 type;
+	u8 delay;
+	u32 count;
+	u8 cmd;
+	u8 para_list[64];
+};
+
+static void push_table(struct LCM_setting_table *table, unsigned int count)
+{
+    unsigned int i, dly;
+
+    for(i = 0; i < count; i++)
+    {
+		unsigned char cmd;
+		cmd = table[i].cmd;
+		dly = table[i].delay;
+		switch (cmd)
+		{
+			//case REGFLAG_DELAY :
+			//mdelay(table[i].count);
+			//break;
+
+			default:
+			ssd2828_set_cmdq(cmd, table[i].count, table[i].para_list);
+			if(dly)
+				panel_simple_sleep(dly);
+			break;
+		}
+    }
+}
+
+#define HFP     80		//160
+#define HBP     80		//160
+#define HSA     14         	// h pulse width
+
+#define VFP     30
+#define VBP     16 		// 12  burst mode, need include sync pulse width
+#define VSA     4 
+
+#define LCD_XSIZE	400
+#define LCD_YSIZE	1280
+
+unsigned char hsa=HSA;
+unsigned char hfp=HFP;
+unsigned char hbp=HBP;
+unsigned char vsa=VSA;
+unsigned char vfp=VFP;
+unsigned char vbp=VBP;
+
+//
+struct LCM_setting_table panel_initialization_setting[] = {
+{0x15, 0x00, 0x02, 0xCD, {0xAA}},
+{0x15, 0x00, 0x02, 0x32, {0x00}},
+{0x15, 0x00, 0x02, 0x35, {0x27}},
+{0x15, 0x00, 0x02, 0x47, {0x15}},
+{0x15, 0x00, 0x02, 0x48, {0x06}},
+{0x15, 0x00, 0x02, 0x33, {0x38}},  //38
+{0x15, 0x00, 0x02, 0x3A, {0x02}},
+{0x15, 0x00, 0x02, 0x29, {0x15}},
+{0x15, 0x00, 0x02, 0x36, {0x41}},
+{0x15, 0x00, 0x02, 0x67, {0x82}},
+{0x39, 0x00, 0x09, 0x57, {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
+{0x15, 0x00, 0x02, 0x69, {0x27}},
+{0x39, 0x00, 0x09, 0x55, {0x08, 0x00, 0x08, 0x00, 0x08, 0x00, 0x08, 0x00}},
+{0x39, 0x00, 0x11, 0x56, {0x1F, 0x00, 0x1F, 0x00, 0x1F, 0x00, 0x1F, 0x00, 0x1F, 0x00, 0x1F, 0x00, 0x1F, 0x00, 0x1F, 0x00}},
+{0x15, 0x00, 0x02, 0x2B, {0x00}},
+{0x15, 0x00, 0x02, 0x68, {0x26}},
+{0x15, 0x00, 0x02, 0x6C, {0x88}},
+{0x15, 0x00, 0x02, 0x4F, {0x00}},
+{0x39, 0x00, 0x14, 0x53, {0x1D, 0x14, 0x13, 0x10, 0x11, 0x0F, 0x11, 0x13, 0x13, 0x0F, 0x09, 0x07, 0x08, 0x0B, 0x0C, 0x0D, 0x0A, 0x07, 0x05}},
+{0x15, 0x00, 0x02, 0x4E, {0x00}},
+{0x39, 0x00, 0x14, 0x54, {0x19, 0x14, 0x13, 0x10, 0x11, 0x0F, 0x11, 0x13, 0x16, 0x0F, 0x09, 0x08, 0x08, 0x0B, 0x0B, 0x0E, 0x0A, 0x07, 0x05}},
+{0x15, 0x00, 0x02, 0x6D, {0x15}},
+{0x39, 0x00, 0x03, 0x73, {0x20, 0x00}},
+{0x39, 0x00, 0x03, 0x74, {0x0B, 0x10}},
+{0x15, 0x00, 0x02, 0x77, {0x00}},
+{0x15, 0x00, 0x02, 0x28, {0x21}},
+{0x15, 0x00, 0x02, 0x63, {0x04}},
+{0x15, 0x00, 0x02, 0x50, {0x80}},
+{0x15, 0x00, 0x02, 0x78, {0x6E}},
+{0x15, 0x00, 0x02, 0x2D, {0x31}},
+{0x15, 0x00, 0x02, 0x76, {0x42}},
+{0x15, 0x00, 0x02, 0x7E, {0x38}},
+{0x15, 0x00, 0x02, 0x5F, {0xA9}},
+{0x15, 0x00, 0x02, 0x41, {0x04}}, 
+{0x15, 0x00, 0x02, 0x68, {0x26}},
+{0x15, 0x00, 0x02, 0x6D, {0x15}},
+{0x15, 0x00, 0x02, 0x36, {0x41}},
+{0x15, 0x00, 0x02, 0x03, {0x08}},
+{0x15, 0x00, 0x02, 0x4D, {0x00}},
+{0x05, 0x78, 0x01, 0x11,{}}
+
+};
+
+
+static void lcm_init(void)
+{
+	push_table(panel_initialization_setting, sizeof(panel_initialization_setting) / sizeof(struct LCM_setting_table));
+}
+
+static void ssd2828_config_register(void)
+{
+#if 1//me
+ 	//SSD2825_Initial
+	SPI_2825_WrCmd(0xb7);  	// set to low speed mode inorder to send cmd for chip init 
+	SPI_WriteData(0x50);	// 50=TX_CLK  70=PCLK     clk is use tx_clk, dcs package
+	SPI_WriteData(0x02);   	// 
+
+	SPI_2825_WrCmd(0xb8);
+	SPI_WriteData(0x00);
+	SPI_WriteData(0x00);   	// VC(Virtual ChannelID) Control Register
+
+	//==================================
+	SPI_2825_WrCmd(0xb9);
+	SPI_WriteData(0x00);	// 0= PLL disable
+	SPI_WriteData(0x00);
+					
+       //TX_CLK/MS should be between 5Mhz to100Mhz
+	SPI_2825_WrCmd(0xBA);	//PLL=(TX_CLK/MS)*NS 8228=480M 4428=240M  061E=120M 4214=240M 821E=360M 8219=300M
+	SPI_WriteData(0x10);	//D7-0=NS(0x01 : NS=1)  MS=1    fpre= fin/MS= 24/1=24       fout=fpre*16=24*16=384
+	SPI_WriteData(0x80);	//D15-14=PLL范围  00=62.5-125 01=126-250 10=251-500 11=501-1000  DB12-8=MS(01:MS=1)
+
+	SPI_2825_WrCmd(0xBB);	//LP Clock Divider LP clock = 288MHz / LPD / 8 = 288 / 8 / 4 = 9MHz
+	SPI_WriteData(0x04);	//D5-0=LPD=0x1 拧C Divide by 2
+	SPI_WriteData(0x00);
+
+	SPI_2825_WrCmd(0xb9);
+	SPI_WriteData(0x01);	// 1=PLL ENABLE
+	SPI_WriteData(0x00);
+    	mdelay(10);
+	
+
+	//==================================
+	SPI_2825_WrCmd(0xDE);	//通道数
+	SPI_WriteData(0x03);	//11=4LANE 10=3LANE 01=2LANE 00=1LANE
+	SPI_WriteData(0x00);
+
+	SPI_2825_WrCmd(0xD6);	//05=BGR  04=RGB       CAN BE DEL
+	SPI_WriteData(0x04);	//D0=0=RGB 1:BGR D1=1=Most significant byte sent first
+	SPI_WriteData(0x00);
+	udelay(100);
+
+            	printk( "ssd2828 set para and write it\n");
+		printk("hfp=%d\n",hfp);
+		printk("hbp=%d\n",hbp);
+		printk("hsa=%d\n",hsa);
+		printk("vfp=%d\n",vfp);
+		printk("vbp=%d\n",vbp);
+		printk("vsa=%d\n",vsa);
+
+	//=================================
+	SPI_2825_WrCmd(0xb1);	// hsw vsw
+	SPI_WriteData(hsa);   	// hsa
+	SPI_WriteData(vsa);  	// vsa
+
+	SPI_2825_WrCmd(0xb2);	
+	SPI_WriteData(hbp);	// hbp  160 + 24 
+	SPI_WriteData(vbp); 	// vbp  10 + 2
+
+	SPI_2825_WrCmd(0xb3);	
+	SPI_WriteData(hfp);	// hfp 
+	SPI_WriteData(vfp); 	// vfp
+
+	SPI_2825_WrCmd(0xb4);	// x 480
+	SPI_WriteData(LCD_XSIZE & 0xFF);
+	SPI_WriteData(LCD_XSIZE>>8); 
+
+	SPI_2825_WrCmd(0xb5);	// y 1280
+	SPI_WriteData(LCD_YSIZE & 0xFF);
+	SPI_WriteData(LCD_YSIZE>>8); 
+
+	SPI_2825_WrCmd(0xb6);	// Video mode and video pixel format Set Color Depth = 24bpp[]
+	SPI_WriteData(0x0B);    // BURST MODE
+	SPI_WriteData(0x00); 
+
+	//================================
+	// config panel
+	SPI_2825_WrCmd(0xb7);        // Generic low power mode
+   	SPI_WriteData(0x10);
+    	SPI_WriteData(0x02); 
+		
+	lcm_init();
+	
+	//================================
+	SPI_2825_WrCmd(0xB7);  // change to high speed mode for send video data
+#if 0	
+	SPI_WriteData(0x4b);  // dcs package, clk src is tx_clk, hs_clk en, video mode enable, clk lane hs mode, hs mode
+	SPI_WriteData(0x02);    
+#else
+	SPI_WriteData(0x4b);  // for esd improve
+	SPI_WriteData(0x00);
+#endif	  
+	udelay(100);
+
+#else//fae
+ 	//SSD2825_Initial
+	SPI_2825_WrCmd(0xb7);  	// set to low speed mode inorder to send cmd for chip init 
+	SPI_WriteData(0x50);	// 50=TX_CLK  70=PCLK     clk is use tx_clk, dcs package
+	SPI_WriteData(0x02);   	// 
+
+	SPI_2825_WrCmd(0xb8);
+	SPI_WriteData(0x00);
+	SPI_WriteData(0x00);   	// VC(Virtual ChannelID) Control Register
+
+	//==================================
+	SPI_2825_WrCmd(0xb9);
+	SPI_WriteData(0x00);	// 0= PLL disable
+	SPI_WriteData(0x00);
+					
+       //TX_CLK/MS should be between 5Mhz to100Mhz
+	SPI_2825_WrCmd(0xBA);	//PLL=(TX_CLK/MS)*NS 8228=480M 4428=240M  061E=120M 4214=240M 821E=360M 8219=300M
+	SPI_WriteData(0x0d);	//D7-0=NS(0x01 : NS=1)  MS=1    fpre= fin/MS= 24/1=24       fout=fpre*16=24*16=384
+	SPI_WriteData(0x81);	//D15-14=PLL范围  00=62.5-125 01=126-250 10=251-500 11=501-1000  DB12-8=MS(01:MS=1)
+
+	SPI_2825_WrCmd(0xBB);	//LP Clock Divider LP clock = 288MHz / LPD / 8 = 288 / 8 / 4 = 9MHz
+	SPI_WriteData(0x0a);	//D5-0=LPD=0x1 拧C Divide by 2
+	SPI_WriteData(0x00);
+
+	SPI_2825_WrCmd(0xb9);
+	SPI_WriteData(0x01);	// 1=PLL ENABLE
+	SPI_WriteData(0x00);
+    	mdelay(10);
+	
+
+	//==================================
+	SPI_2825_WrCmd(0xDE);	//通道数
+	SPI_WriteData(0x03);	//11=4LANE 10=3LANE 01=2LANE 00=1LANE
+	SPI_WriteData(0x00);
+
+	SPI_2825_WrCmd(0xD6);	//05=BGR  04=RGB       CAN BE DEL
+	SPI_WriteData(0x05);	//D0=0=RGB 1:BGR D1=1=Most significant byte sent first
+	SPI_WriteData(0x00);
+	udelay(100);
+
+            	printk( "ssd2828 set para and write it\n");
+		printk("hfp=%d\n",hfp);
+		printk("hbp=%d\n",hbp);
+		printk("hsa=%d\n",hsa);
+		printk("vfp=%d\n",vfp);
+		printk("vbp=%d\n",vbp);
+		printk("vsa=%d\n",vsa);
+
+	//=================================
+	SPI_2825_WrCmd(0xb1);	// hsw vsw
+	SPI_WriteData(hsa);   	// hsa
+	SPI_WriteData(vsa);  	// vsa
+
+	SPI_2825_WrCmd(0xb2);	
+	SPI_WriteData(hbp);	// hbp  160 + 24 
+	SPI_WriteData(vbp); 	// vbp  10 + 2
+
+	SPI_2825_WrCmd(0xb3);	
+	SPI_WriteData(hfp);	// hfp 
+	SPI_WriteData(vfp); 	// vfp
+
+	SPI_2825_WrCmd(0xb4);	// x 480
+	SPI_WriteData(LCD_XSIZE & 0xFF);
+	SPI_WriteData(LCD_XSIZE>>8); 
+
+	SPI_2825_WrCmd(0xb5);	// y 1280
+	SPI_WriteData(LCD_YSIZE & 0xFF);
+	SPI_WriteData(LCD_YSIZE>>8); 
+
+	SPI_2825_WrCmd(0xb6);	// Video mode and video pixel format Set Color Depth = 24bpp[]
+	SPI_WriteData(0x0B);    // BURST MODE
+	SPI_WriteData(0x00); 
+
+	//================================
+	// config panel
+	SPI_2825_WrCmd(0xb7);        // Generic low power mode
+   	SPI_WriteData(0x10);
+    	SPI_WriteData(0x02); 
+		
+	lcm_init();
+	
+	//================================
+	SPI_2825_WrCmd(0xB7);  // change to high speed mode for send video data
+	SPI_WriteData(0x4b);  // for esd improve
+	SPI_WriteData(0x00); 
+	udelay(100);
+
+#endif
+
+}
+/*
+static void lcd_panel_reset(void)
+{
+	LCD_RESET_SET;
+	mdelay(1);
+	LCD_RESET_CLR;
+	mdelay(20);			// para 5 or 10 always is 40ms ?
+	LCD_RESET_SET;
+	mdelay(2);
+}
+*/
+static void LCD_panel_init(void)
+{
+    //lcd_panel_reset();
+	ssd2828_config_register();
+}
+
+static int panel_simple_myspi_send_cmds(struct panel_simple *panel,
+				      struct panel_cmds *cmds)
+{
+	printk("====================zwh %s %d\n", __FUNCTION__, __LINE__);
+	panel_simple_sleep(50);
+	ssd2828_esd_check();
+	LCD_panel_init();
+	return 0;
+}
+
+//调试========================================================================
+//echo hfp hbp hsa vfp vbp vsa > /proc/ssd2828
+//echo 160 160 24 12 10 2 w> /proc/ssd2828
+
+//echo "addr data w">/proc/ssd2828
+//echo "0 0 r">/proc/ssd2828
+
+
+int debug_panel_simple_prepare(struct panel_simple *p);
+static ssize_t ssd2828_proc_write(struct file *filp, const char __user *buf, size_t count, loff_t *off)
+{
+    	char *value;
+    	char *temp;
+    	char *ptr;
+    	unsigned int data[10];
+    	char msg[255]={0};
+    	int i = 0;
+	
+	ptr=NULL;
+    	printk("device_proc_write: %s\n", buf);
+
+    	if (copy_from_user((void*)msg, buf, count)){
+        	printk(KERN_ERR "device_proc_write copy_from_user err\n");
+        	return -EFAULT;
+   	}
+    	printk("msg: %s\n", msg);
+    	value = msg;								//simple_strtoul(msg,NULL,0);
+    	ptr = strrchr(value,'w');//查找一个字符串在另一个字符串中 末次 出现的位置，并返回从字符串中的这个位置起，一直到字符串结束的所有字符
+								//得到w后面的字符串
+	printk("msg: %s\n", msg);
+	printk("value: %s\n", value);
+
+    	while((temp = strsep(&value," "))!= NULL){//返回分隔符前面的字符串，s将指向分隔符之后的字符串
+        	if(i == 0){
+            		sscanf(temp,"%d",&data[0]);	//hfp
+			hfp=data[0];
+        	}else if(i == 1){
+            		sscanf(temp,"%d",&data[1]);	//hbp
+			hbp=data[1];
+        	}else if(i == 2){
+            		sscanf(temp,"%d",&data[2]);	//hsa
+			hsa=data[2];
+        	}else if(i == 3){
+            		sscanf(temp,"%d",&data[3]);	//vfp
+			vfp=data[3];
+        	}else if(i == 4){
+            		sscanf(temp,"%d",&data[4]);	//vbp
+			vbp=data[4];
+        	}else if(i == 5){
+            		sscanf(temp,"%d",&data[5]);	//vsa
+			vsa=data[5];
+        	}else if(i == 6){
+            		sscanf(temp,"%d",&data[6]);
+        	}
+        	i++;//统计参数个数
+    	}
+		
+	if(i){
+		//for(j=0; j<i-1; j++)
+		// 	printk("debug data[0x%d]\n",buff[j]);
+	}
+
+        if(ptr != NULL){
+            	printk( "ssd2828 set para \n");
+		printk("hfp=%d\n",hfp);
+		printk("hbp=%d\n",hbp);
+		printk("hsa=%d\n",hsa);
+		printk("vfp=%d\n",vfp);
+		printk("vbp=%d\n",vbp);
+		printk("vsa=%d\n",vsa);
+		//debug_panel_simple_prepare(mypanel);
+        }else{
+            	printk( "ssd2828 set para only\n");
+        }
+    	
+    	return count;
+}
+static ssize_t ssd2828_proc_read(struct file *file, char __user *page, size_t size, loff_t *ppos)
+{
+	return -1;
+}
+
+static const struct file_operations ssd2828_ops = {
+    .owner = THIS_MODULE,
+    .read = ssd2828_proc_read,
+    .write = ssd2828_proc_write,
+};
+
+static struct proc_dir_entry *procfile = NULL;
+
+static int ssd2828_debug_init(void)
+{
+    int res = 0;
+    printk("ssd2828_debug_init!\n");
+
+	procfile = proc_create("ssd2828", 0666, NULL, &ssd2828_ops);
+    if(procfile == NULL) {
+        res = -ENOMEM;
+        printk(KERN_ERR "create procfile error!\n");
+    } else {
+
+    }
+
+    printk("radio_debug_init ok!\n");
+    return res;
+}
+
+static const struct display_timing test_timing = {
+	.pixelclock = { 48000000, 48000000, 48000000 },
+	.hactive = { 400, 400, 400 },
+	.hfront_porch = { 1, 1, 10 },
+	.hback_porch = { 1, 1, 10 },
+	
+	.hsync_len = { 58, 158, 661 },
+	.vactive = { 1280, 1280, 1280 },
+	.vfront_porch = { 1, 1, 10 },
+	.vback_porch = { 1, 1, 10 },
+	.vsync_len = { 1, 21, 203 },
+	.flags = DISPLAY_FLAGS_DE_HIGH,
+};
+
+
diff --git a/drivers/gpu/drm/rockchip/rockchip_drm_drv.c b/drivers/gpu/drm/rockchip/rockchip_drm_drv.c
index e10110cb7453..4ff8e89323d2 100644
--- a/drivers/gpu/drm/rockchip/rockchip_drm_drv.c
+++ b/drivers/gpu/drm/rockchip/rockchip_drm_drv.c
@@ -474,13 +474,13 @@ static int setup_initial_state(struct drm_device *drm_dev,
 
 	funcs = connector->helper_private;
 	conn_state->best_encoder = funcs->best_encoder(connector);
-	if (funcs->loader_protect)
-		funcs->loader_protect(connector, true);
-	connector->loader_protect = true;
-	encoder_funcs = conn_state->best_encoder->helper_private;
-	if (encoder_funcs->loader_protect)
-		encoder_funcs->loader_protect(conn_state->best_encoder, true);
-	conn_state->best_encoder->loader_protect = true;
+	// if (funcs->loader_protect)
+	// 	funcs->loader_protect(connector, true);
+	// connector->loader_protect = true;
+	// encoder_funcs = conn_state->best_encoder->helper_private;
+	// if (encoder_funcs->loader_protect)
+	// 	encoder_funcs->loader_protect(conn_state->best_encoder, true);
+	// conn_state->best_encoder->loader_protect = true;
 	num_modes = connector->funcs->fill_modes(connector, 4096, 4096);
 	if (!num_modes) {
 		dev_err(drm_dev->dev, "connector[%s] can't found any modes\n",
@@ -503,10 +503,25 @@ static int setup_initial_state(struct drm_device *drm_dev,
 	}
 
 	if (!found) {
-		ret = -EINVAL;
-		goto error_conn;
+		// ret = -EINVAL;
+		// goto error_conn;
+		list_for_each_entry(mode, &connector->modes, head) {
+			if (mode->type & DRM_MODE_TYPE_PREFERRED) {
+				found = 1;
+				break;
+			}
+		}
 	}
 
+	if(!found){
+		mode = list_first_entry_or_null(&connector->modes,struct drm_display_mode,head);
+		if(!mode){
+			dev_err(drm_dev->dev,"failed to find available modes\n");
+			ret = -EINVAL;
+			goto error_conn;
+		}
+ 	}
+
 	set->mode = mode;
 	crtc_state = drm_atomic_get_crtc_state(state, crtc);
 	if (IS_ERR(crtc_state)) {
@@ -517,7 +532,16 @@ static int setup_initial_state(struct drm_device *drm_dev,
 	drm_mode_copy(&crtc_state->adjusted_mode, mode);
 	if (!match || !is_crtc_enabled) {
 		set->mode_changed = true;
+		connector->loader_protect = false;
+		conn_state->best_encoder->loader_protect = false;
 	} else {
+		if (funcs->loader_protect)
+			funcs->loader_protect(connector, true);
+		encoder_funcs = conn_state->best_encoder->helper_private;
+		if (encoder_funcs->loader_protect)
+			encoder_funcs->loader_protect(conn_state->best_encoder,true);
+		conn_state->best_encoder->loader_protect = true;
+
 		ret = drm_atomic_set_crtc_for_connector(conn_state, crtc);
 		if (ret)
 			goto error_conn;
@@ -582,13 +606,23 @@ error_crtc:
 	if (priv->crtc_funcs[pipe] && priv->crtc_funcs[pipe]->loader_protect)
 		priv->crtc_funcs[pipe]->loader_protect(crtc, false);
 error_conn:
-	if (funcs->loader_protect)
-		funcs->loader_protect(connector, false);
-	connector->loader_protect = false;
-	if (encoder_funcs->loader_protect)
-		encoder_funcs->loader_protect(conn_state->best_encoder, false);
-	conn_state->best_encoder->loader_protect = false;
-
+	// if (funcs->loader_protect)
+	// 	funcs->loader_protect(connector, false);
+	// connector->loader_protect = false;
+	// if (encoder_funcs->loader_protect)
+	// 	encoder_funcs->loader_protect(conn_state->best_encoder, false);
+	// conn_state->best_encoder->loader_protect = false;
+	printk("===lijc;%s,error_conn\n",__func__);
+	if (connector->loader_protect) {
+		if (funcs->loader_protect)
+			funcs->loader_protect(connector, false);
+		connector->loader_protect = false;
+	}
+	if (conn_state->best_encoder->loader_protect) {
+		if (encoder_funcs->loader_protect)
+			encoder_funcs->loader_protect(conn_state->best_encoder, false);
+		conn_state->best_encoder->loader_protect = false;
+	}
 	return ret;
 }
 
diff --git a/drivers/input/touchscreen/Kconfig b/drivers/input/touchscreen/Kconfig
index 3c0a61d23709..cfe59658c08b 100644
--- a/drivers/input/touchscreen/Kconfig
+++ b/drivers/input/touchscreen/Kconfig
@@ -1165,4 +1165,15 @@ config TOUCHSCREEN_VTL_CT36X
 config TOUCHSCREEN_GT1X
 	tristate "GT1X touchscreens support"
 
+config TOUCHSCREEN_HY4635
+	tristate "hy4635 touchscreens support"
+	default y
+	help
+	  Say Y here if you have a touchscreen using hy4635_ts.
+
+	  If unsure, say N.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called hy4635_ts.
+
 endif
diff --git a/drivers/input/touchscreen/Makefile b/drivers/input/touchscreen/Makefile
index b66414e38283..f3fe344ddaeb 100644
--- a/drivers/input/touchscreen/Makefile
+++ b/drivers/input/touchscreen/Makefile
@@ -102,3 +102,4 @@ obj-$(CONFIG_TOUCHSCREEN_COLIBRI_VF50)	+= colibri-vf50-ts.o
 obj-$(CONFIG_TOUCHSCREEN_ROHM_BU21023)	+= rohm_bu21023.o
 obj-$(CONFIG_TOUCHSCREEN_VTL_CT36X)	+= vtl_ts/
 obj-$(CONFIG_TOUCHSCREEN_GT1X)		+= gt1x/
+obj-$(CONFIG_TOUCHSCREEN_HY4635)	+= hy4635_ts.o
\ No newline at end of file
diff --git a/drivers/input/touchscreen/hy4635_ts.c b/drivers/input/touchscreen/hy4635_ts.c
new file mode 100755
index 000000000000..e34ef6ea0e9f
--- /dev/null
+++ b/drivers/input/touchscreen/hy4635_ts.c
@@ -0,0 +1,389 @@
+/*
+ * FocalTech hy4635 TouchScreen driver.
+ *
+ * Copyright (c) 2022  SHENZHEN topband Ltd.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/i2c.h>
+#include <linux/input.h>
+#include <linux/input/mt.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/property.h>
+#include <linux/workqueue.h>
+#include <linux/timer.h>
+
+#define hy4635_MAX_TOUCH_POINTS		1
+
+#define hy4635_EVENT_NONE		0
+#define hy4635_EVENT_DOWN		1
+#define hy4635_EVENT_MOVE		2
+#define hy4635_EVENT_CONTACT	3
+#define hy4635_EVENT_UP			4
+
+struct hy4635_data {
+	struct i2c_adapter *adapter;
+	struct i2c_client *client;
+	struct input_dev *input;
+	struct gpio_desc *reset_gpio;
+	struct gpio_desc *int_gpio;
+	u32 max_x;
+	u32 max_y;
+	bool invert_x;
+	bool invert_y;
+	bool swap_xy;
+
+	struct delayed_work test_delaywork;
+};
+
+/*
+ * This struct is a touchpoint as stored in hardware.  Note that the id,
+ * as well as the event, are stored in the upper nybble of the hi byte.
+ */
+struct hy4635_touchpoint {
+	u8	id;
+	u8  x_l;
+	u8  x_h;
+	u8  y_l;
+	u8  y_h;
+	u8  pressure;
+	u8  event_id;
+} __packed;
+
+/* This packet represents the register map as read from offset 0 */
+struct hy4635_packet {
+	u8 touches;
+	struct hy4635_touchpoint points[hy4635_MAX_TOUCH_POINTS];
+} __packed;
+
+struct hy4635_data hy4635_d;
+struct hy4635_data *hy4635;
+static void hy4635_reset(struct hy4635_data *hy4635);
+static int hy4635_read(struct i2c_client *client, u16 reg, u8 len, void *data);
+
+static int hy4635_read(struct i2c_client *client, u16 reg, u8 len, void *data)
+{
+	//int error;
+	uint8_t u8_addr[2];
+	struct i2c_msg msg[2];
+	int ret;
+
+	u8_addr[0] = ((reg >> 8) & 0xff);
+	u8_addr[1] = reg & 0xff;
+
+	msg[0].addr = 0x48;
+	msg[0].flags = 0;
+	msg[0].buf = u8_addr;
+	msg[0].len = 2;
+
+	msg[1].addr = 0x48;
+	msg[1].flags = I2C_M_RD;
+	msg[1].buf = data;
+	msg[1].len = len;
+
+	ret = i2c_transfer(client->adapter,msg,1);
+	if(ret != 1)
+	{
+		printk("==-lijc:%s[0x%02x] send reg[0x%04x] error!!\n",__func__,msg[0].addr,reg);
+		return (ret<0)?ret:(-EIO);
+	}
+	udelay(10);
+	ret = i2c_transfer(client->adapter,&msg[1],1);
+	if(ret != 1)
+	{
+		printk("==-lijc:%s send addr error!!\n",__func__);
+		return (ret<0)?ret:(-EIO);
+	}
+
+	return 0;
+#if 0
+	error = i2c_smbus_read_i2c_block_data(client, reg, len, data);
+	if (error < 0)
+		return error;
+
+	if (error != len)
+		return -EIO;
+
+	return 0;
+#endif
+}
+
+static irqreturn_t hy4635_interrupt(int irq, void *dev_id)
+{
+	struct hy4635_data *hy4635 = dev_id;
+	struct device *dev = &hy4635->client->dev;
+	struct input_dev *input = hy4635->input;
+	struct hy4635_packet buf;
+	u8 touches;
+	int i, error;
+	u16 x;
+	u16 y;
+	bool active;
+    
+	error = hy4635_read(hy4635->client, 0x1001, sizeof(buf), &buf);
+	if (error) {
+		dev_err(dev, "read touchdata failed %d\n", error);
+		return IRQ_HANDLED;
+	}
+
+	touches = buf.touches;
+	if (touches > hy4635_MAX_TOUCH_POINTS) {
+		dev_dbg(dev,
+			"%d touch points reported, only %d are supported\n",
+			touches, hy4635_MAX_TOUCH_POINTS);
+		touches = hy4635_MAX_TOUCH_POINTS;
+	}
+
+	for (i = 0; i < touches; i++) {
+		struct hy4635_touchpoint *point = &buf.points[i];
+		x = point->x_h;
+		x = ((x << 8)&0xff00)|((point->x_l)&0xff);
+		y = point->y_h;
+		y = ((y << 8)&0xff00)|((point->y_l)&0xff);
+
+		switch(point->event_id)
+		{
+		case hy4635_EVENT_NONE:
+			active = false;
+			break;
+		case hy4635_EVENT_DOWN:
+		case hy4635_EVENT_MOVE:
+		case hy4635_EVENT_CONTACT:
+			active = true;
+			break;
+		case hy4635_EVENT_UP:
+			active = false;
+			break;
+		default:
+			printk("ERROR: hy4635_ts.c dont support ev[%d]:%d\n",i,point->event_id);
+		};
+
+		input_mt_slot(input, point->id);
+		input_mt_report_slot_state(input, MT_TOOL_FINGER, active);
+		if (!active)
+			continue;
+
+		if (hy4635->invert_x)
+			x = hy4635->max_x - x;
+
+		if (hy4635->invert_y)
+			y = hy4635->max_y - y;
+
+		if (hy4635->swap_xy) {
+			input_report_abs(input, ABS_MT_POSITION_X, y);
+			input_report_abs(input, ABS_MT_POSITION_Y, x);
+		} else {
+			input_report_abs(input, ABS_MT_POSITION_X, x);
+			input_report_abs(input, ABS_MT_POSITION_Y, y);
+		}
+		
+#if 0
+		if(hy4635->swap_xy)
+		{
+			printk("===lijc:tp_raw: x=%d,y=%d,a=%d\n",y,x,active);
+		}
+		else
+		{
+			printk("===lijc:tp_raw: x=%d,y=%d,a=%d\n",x,y,active);
+		}
+		//input_report_abs(input, ABS_MT_PRESSURE,point->pressure);
+#endif
+	}
+
+	input_mt_sync_frame(input);
+	input_sync(input);
+
+	return IRQ_HANDLED;
+}
+
+static void hy4635_debug_info(struct hy4635_data *hy4635)
+{
+	//struct device *dev = &hy4635->client->dev;
+
+	printk("hy4635 probe sucessful:max[x=%d,y=%d],invert[x=%d,y=%d,xy=%d]\n",
+		   hy4635->max_x, hy4635->max_y,hy4635->invert_x,hy4635->invert_y,hy4635->swap_xy);
+
+}
+
+static void hy4635_reset(struct hy4635_data *hy4635)
+{
+	if (!hy4635->reset_gpio)
+		return;
+
+	gpiod_direction_output(hy4635->reset_gpio, 0);
+	msleep(10);
+	gpiod_direction_output(hy4635->reset_gpio, 1);
+	msleep(10);
+	gpiod_direction_output(hy4635->reset_gpio, 0);
+	msleep(120);
+	printk("===lijc:%s\n",__func__);
+}
+
+static int hy4635_probe(struct i2c_client *client,
+			const struct i2c_device_id *id)
+{
+	struct device *dev = &client->dev;
+	struct hy4635_data *hy4635;
+	struct input_dev *input;
+	u32 fuzz_x = 0, fuzz_y = 0;
+	u8 val;
+	int error;
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C))
+		return -ENXIO;
+
+	if (!client->irq) {
+		dev_err(dev, "irq is missing\n");
+		return -EINVAL;
+	}
+
+	//hy4635 = devm_kzalloc(dev, sizeof(*hy4635), GFP_KERNEL);
+	hy4635 = &hy4635_d;
+	if (!hy4635)
+		return -ENOMEM;
+
+	hy4635->client = client;
+	hy4635->adapter = client->adapter;
+
+	hy4635->reset_gpio = devm_gpiod_get_optional(dev, "reset",
+						     0);
+	if (IS_ERR(hy4635->reset_gpio)) {
+		error = PTR_ERR(hy4635->reset_gpio);
+		if (error != -EPROBE_DEFER)
+			dev_err(dev, "error getting reset gpio: %d\n", error);
+		return error;
+	}
+
+	hy4635->int_gpio = devm_gpiod_get_optional(dev, "intt",
+						     GPIOD_IN);
+	if (IS_ERR(hy4635->int_gpio)) {
+		error = PTR_ERR(hy4635->int_gpio);
+		if (error != -EPROBE_DEFER)
+			dev_err(dev, "error getting reset gpio: %d\n", error);
+		return error;
+	}
+
+	hy4635_reset(hy4635);
+
+	/* verify that the controller is present */
+	error = hy4635_read(client, 0x00, 1, &val);
+	if (error) {
+		dev_err(dev, "failed to read from controller: %d\n", error);
+		return error;
+	}
+	else
+	{
+		printk("===lijc: i2c read ok!\n");
+	}
+
+	input = devm_input_allocate_device(dev);
+	if (!input)
+		return -ENOMEM;
+
+	hy4635->input = input;
+	input->name = client->name;
+	input->id.bustype = BUS_I2C;
+
+	if (device_property_read_u32(dev, "touchscreen-size-x",
+				     &hy4635->max_x) ||
+	    device_property_read_u32(dev, "touchscreen-size-y",
+				     &hy4635->max_y)) {
+		dev_err(dev, "touchscreen-size-x and/or -y missing\n");
+		return -EINVAL;
+	}
+
+	device_property_read_u32(dev, "touchscreen-fuzz-x", &fuzz_x);
+	device_property_read_u32(dev, "touchscreen-fuzz-y", &fuzz_y);
+	hy4635->invert_x = device_property_read_bool(dev,
+						     "touchscreen-inverted-x");
+	hy4635->invert_y = device_property_read_bool(dev,
+						     "touchscreen-inverted-y");
+	hy4635->swap_xy = device_property_read_bool(dev,
+						    "touchscreen-swapped-x-y");
+
+	if (hy4635->swap_xy) {
+		input_set_abs_params(input, ABS_MT_POSITION_X, 0,
+				     hy4635->max_y, fuzz_y, 0);
+		input_set_abs_params(input, ABS_MT_POSITION_Y, 0,
+				     hy4635->max_x, fuzz_x, 0);
+	} else {
+		input_set_abs_params(input, ABS_MT_POSITION_X, 0,
+				     hy4635->max_x, fuzz_x, 0);
+		input_set_abs_params(input, ABS_MT_POSITION_Y, 0,
+				     hy4635->max_y, fuzz_y, 0);
+	}
+
+	error = input_mt_init_slots(input, hy4635_MAX_TOUCH_POINTS,
+				    INPUT_MT_DIRECT | INPUT_MT_DROP_UNUSED);
+	if (error)
+		return error;
+
+	error = devm_request_threaded_irq(dev, client->irq, NULL,
+					  hy4635_interrupt, IRQF_ONESHOT,
+					  client->name, hy4635);
+	if (error) {
+		dev_err(dev, "request irq %d failed: %d\n", client->irq, error);
+		return error;
+	}
+
+	error = input_register_device(input);
+	if (error) {
+		dev_err(dev, "failed to register input device: %d\n", error);
+		return error;
+	}
+
+	hy4635_debug_info(hy4635);
+	return 0;
+}
+
+#ifdef CONFIG_OF
+static const struct of_device_id hy4635_of_match[] = {
+	{ .compatible = "rockchip,hy4635", },
+	{ }
+};
+#endif
+
+static const struct i2c_device_id hy4635_id[] = {
+	{ "hy4635", },
+	{ }
+};
+
+static struct i2c_driver hy4635_driver = {
+	.driver = {
+		.name = "hy4635",
+		.of_match_table = of_match_ptr(hy4635_of_match),
+	},
+	.probe = hy4635_probe,
+	.id_table = hy4635_id,
+};
+
+static int hy4635_init(void)
+{
+	int ret;
+	ret = i2c_add_driver(&hy4635_driver);
+	return ret;
+}
+
+static void __exit hy4635_exit(void)
+{
+	printk("===lijc: hy4635 exit\n");
+	i2c_del_driver(&hy4635_driver);
+}
+
+late_initcall(hy4635_init);
+module_exit(hy4635_exit);
+
+MODULE_AUTHOR("Jiuchun Li<lijc@topband.com.cn>");
+MODULE_DESCRIPTION("hy4346 TouchScreen driver");
+MODULE_LICENSE("GPL v2");
diff --git a/logo.bmp b/logo.bmp
old mode 100644
new mode 100755
index 13a761f90b80..8538599936a1
Binary files a/logo.bmp and b/logo.bmp differ
diff --git a/logo_kernel.bmp b/logo_kernel.bmp
old mode 100644
new mode 100755
index 271721846e8d..f4b9219fb7fc
Binary files a/logo_kernel.bmp and b/logo_kernel.bmp differ
